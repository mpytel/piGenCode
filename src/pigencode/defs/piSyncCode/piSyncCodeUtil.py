import re
import ast
import traceback
from json import dump
from pathlib import Path
from typing import Dict, List, Tuple, Optional, Set, Any
from ..logIt import printIt, lable
from ..fileIO import getKeyItem, piGCDirs
from ..getSeedPath import getSeedPath
from ...classes.piSeeds import extractPiSeed
from ...classes.piGenCode import PiGenCode

global options
global devExept
devExept = True
global showDefNames
# showDefNames = lable.ABORTPRT
# showDefNames = lable.IMPORT
showDefNames = lable.ABORTPRT
showDefNames01 = lable.ABORTPRT
showDefNames02 = lable.ABORTPRT
showDefNames03 = lable.ABORTPRT
# Intelligent pattern detection functions

def isExactDefaultStrCode(methodCode: List[str], className: str) -> bool:
    """
    Check if the strCode exactly matches what would be generated by default.
    This is a precise check for idempotency.
    """
    printIt('isExactDefaultStrCode', showDefNames02)

    if not methodCode:
        return True

    # Join the method code
    actualCode = '\n'.join(methodCode).strip()

    # Check if it starts with the expected pattern
    if not actualCode.startswith('def __str__(self):'):
        return False

    # Check for the exact default pattern structure
    expectedPatterns = [
        f'rtnStr = "{className} = ',
        'return rtnStr',
        'rtnStr +='
    ]

    # All patterns must be present
    for pattern in expectedPatterns:
        if pattern not in actualCode:
            return False

    # Check that it doesn't have any custom logic beyond the basic pattern
    # Split into lines and check each line
    lines = actualCode.split('\n')

    for line in lines:
        line = line.strip()
        if not line:
            continue

        # Skip expected default patterns
        if (line.startswith('def __str__(self):') or
            line.startswith('rtnStr = ') or
            line.startswith('rtnStr +=') or
                line == 'return rtnStr'):
            continue

        # If we find any other code, it's custom
        return False

    return True

def isCustomCodeUsingArchitecture(elementType: str, actualCode: List[str], className: str, seedContent: str) -> bool:
    """
    Determine if code is custom by comparing with generated default using the new architecture.
    Returns True if the code is genuinely custom (different from default).
    """
    printIt('isCustomCodeUsingArchitecture', showDefNames02)

    try:

        # Create a temporary PiGenCode instance to generate default code
        tempGen = PiGenCode()

        # We need to load the piSeed data into the temp generator
        # Parse the seedContent to extract the piClassGC data
        seedLines = seedContent.strip().split('\n')

        # Find the className in the seed content
        piClassGCData = {
            "piClassName": className,
            "initArguments": {},
            "inheritance": [],
            "strCode": [],
            "jsonCode": [],
            "classComment": [],
            "fromPiClasses": [],
            "globals": [],
            "preSuperInitCode": [],
            "postSuperInitCode": [],
            "initAppendCode": [],
            "genProps": "",
            "globalCode": []
        }

        # Parse the seed content to extract initArguments and other data
        for line in seedLines:
            if line.strip() and not line.startswith('#'):
                parts = line.split(' ', 2)
                if len(parts) >= 3:
                    piType, piKey, piValue = parts[0], parts[1], parts[2].strip(
                        '"')

                    # Extract initArguments
                    if ':initArguments:' in piKey:
                        argName = piKey.split(':initArguments:')[1]
                        if argName not in piClassGCData["initArguments"]:
                            piClassGCData["initArguments"][argName] = {}
                        if piType == "piValue":
                            if piValue in ['str', 'int', 'float', 'bool', 'dict', 'list']:
                                piClassGCData["initArguments"][argName]["type"] = piValue
                            else:
                                piClassGCData["initArguments"][argName]["type"] = piValue

        # Set up the temp generator with the parsed data
        tempGen.piClassName = className
        tempGen.initArguments = piClassGCData["initArguments"]
        tempGen.inheritance = piClassGCData["inheritance"]
        tempGen.strCode = []  # Force empty to get default
        tempGen.jsonCode = []  # Force empty to get default
        tempGen.classComment = []  # Force empty to get default
        tempGen.fromPiClasses = []  # Force empty to get default
        tempGen.globals = []  # Force empty to get default
        tempGen.preSuperInitCode = []  # Force empty to get default
        tempGen.postSuperInitCode = []  # Force empty to get default
        tempGen.initAppendCode = []  # Force empty to get default
        tempGen.genProps = ""  # Force empty to get default
        tempGen.globalCode = []  # Force empty to get default
        tempGen.indent = "    "

        # Generate what the default code should be
        defaultCode = tempGen.getDefaultElementCode(elementType, 0)

        # Compare actual vs default
        actualCodeStr = '\n'.join(actualCode).strip()
        defaultCodeStr = defaultCode.strip()

        # For debugging - uncomment these lines to see the comparison
        # printIt(f"ACTUAL ({elementType}):\n{repr(actualCodeStr)}", lable.DEBUG)
        # printIt(f"DEFAULT ({elementType}):\n{repr(defaultCodeStr)}", lable.DEBUG)

        # Return True if they're different (custom code)
        return actualCodeStr != defaultCodeStr

    except Exception as e:
        if devExept:
            tb_str = ''.join(traceback.format_exception(None, e, e.__traceback__))
            printIt(f'{tb_str}\n\n --- def isCustomCodeUsingArchitecture', lable.ERROR)
        printIt(
            f"Error in architecture-based comparison for {elementType}: {e}", lable.DEBUG)
        # Fall back to exact detection for strCode
        if elementType == 'strCode':
            return not isExactDefaultStrCode(actualCode, className)
        return True

def isDefaultJsonCode(methodCode: List[str], className: str, initArgs: Dict) -> bool:
    """Check if json() method is just the default generated pattern"""
    printIt('isDefaultJsonCode', showDefNames02)
    if not methodCode or not initArgs:
        return True

    codeStr = '\n'.join(methodCode)

    # Must start with def json(self) -> dict:
    if not codeStr.startswith('def json(self) -> dict:'):
        return False

    # Check for the specific default pattern generated by piGenCode
    # Default pattern includes: rtnDict = {
    if 'rtnDict = {' not in codeStr:
        return False

    # Must contain standard elements for all init args
    argNames = list(initArgs.keys())
    for argName in argNames:
        # Check for the specific formatting pattern: "argName": self.argName,
        if f'"{argName}": self.{argName}' not in codeStr:
            return False  # Missing expected field

    # Check for default pattern indicators
    defaultIndicators = [
        'rtnDict = {',
        'return rtnDict'
    ]

    hasDefaultIndicators = all(
        indicator in codeStr for indicator in defaultIndicators)

    # Check for custom logic indicators (excluding the method definition itself)
    codeLines = methodCode[1:]  # Skip 'def json(self) -> dict:'
    bodyStr = '\n'.join(codeLines)

    customIndicators = [
        'if ', 'for ', 'while ', 'try:', 'except:', 'with ',
        'import ', 'def ', 'class ', 'lambda', '@',
        'print(', 'input(', 'open(', 'file(', 'read(', 'write(',
        'datetime.', 'json.', 'len(', 'str(', 'int(', 'float(', 'bool(',
        'split(', 'join(', 'replace(', 'format(',
        # Additional indicators for json method customization
        'json.dumps', 'json.loads', '.isoformat()', '.strftime(',
        'isinstance(', 'hasattr(', 'getattr('
    ]

    for indicator in customIndicators:
        if indicator in bodyStr:
            return False  # Contains custom logic

    # Additional check: if the method is very short and follows the pattern, likely default
    if len(methodCode) < 15 and hasDefaultIndicators:
        return True

    # If it has the default structure and no custom logic, consider it default
    return hasDefaultIndicators


def isDefaultInitAppendCode(codeLines: List[str], initArgs: Dict) -> bool:
    """Check if initAppendCode is just standard parameter assignments"""
    printIt('isDefaultInitAppendCode', showDefNames02)
    if not codeLines:
        return True

    # Check if all lines are just standard self.param = param assignments
    standardAssignments = 0
    totalLines = 0

    for line in codeLines:
        stripped = line.strip()
        if stripped:
            totalLines += 1

            # Skip constructor signature lines and type annotations
            if ':' in stripped and ('str' in stripped or 'int' in stripped or 'bool' in stripped or 'dict' in stripped):
                continue

            # Check for standard assignment pattern: self.param = param
            if stripped.startswith('self.') and ' = ' in stripped:
                parts = stripped.split(' = ')
                if len(parts) == 2:
                    leftSide = parts[0].strip()
                    rightSide = parts[1].strip()

                    # Extract parameter name from self.param
                    if leftSide.startswith('self.'):
                        paramName = leftSide[5:]  # Remove 'self.'

                        # Check if it's a simple assignment: self.param = param
                        if rightSide == paramName:
                            standardAssignments += 1
                        # Check for Pi type assignments: if param: self.param = param; else: self.param = ParamType()
                        elif rightSide.startswith('if ') or rightSide.startswith('else:'):
                            # This is likely a Pi type default assignment pattern
                            standardAssignments += 1

    # If most lines are standard assignments, consider it default
    # Allow for some flexibility but require majority to be standard
    return totalLines > 0 and standardAssignments >= (totalLines * 0.9)


def hasElegantValueReferences(seedContent: str, className: str) -> bool:
    """Check if the seed file uses elegant pi.piBase:field references"""
    printIt('hasElegantValueReferences', showDefNames02)
    lines = seedContent.split('\n')
    argValuePattern = rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:initArguments:\w+:value\s+pi\.'

    for line in lines:
        if re.match(argValuePattern, line):
            return True  # Found elegant reference

    return False


def extractInitArgsFromSeed(seedContent: str, className: str) -> Dict[str, str]:
    """Extract initArguments from seed content for pattern matching"""
    printIt('extractInitArgsFromSeed', showDefNames02)
    lines = seedContent.split('\n')
    initArgs = {}

    argPattern = rf'^piStructC01\s+argument\s+(\w+)\.\s*$'

    for line in lines:
        match = re.match(argPattern, line)
        if match:
            argName = match.group(1)
            initArgs[argName] = 'str'  # Default type

    return initArgs


def extractInitArgsFromSeedDetailed(seedContent: str, className: str) -> Dict[str, Dict[str, str]]:
    """Extract detailed initArguments from seed content including type and value information"""
    printIt('extractInitArgsFromSeedDetailed', showDefNames02)
    lines = seedContent.split('\n')
    initArgs = {}

    # Find argument definitions
    argPattern = rf'^piStructC01\s+argument\s+(\w+)\.\s*$'
    typePattern = rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:initArguments:(\w+):type\s+(.+)$'
    valuePattern = rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:initArguments:(\w+):value\s+(.+)$'

    # First pass: find all arguments
    for line in lines:
        match = re.match(argPattern, line)
        if match:
            argName = match.group(1)
            initArgs[argName] = {'type': 'str', 'value': ''}

    # Second pass: find types and values
    for line in lines:
        # Check for type definitions
        match = re.match(typePattern, line)
        if match:
            argName = match.group(1)
            argType = match.group(2).strip()
            if argName in initArgs:
                initArgs[argName]['type'] = argType

        # Check for value definitions
        match = re.match(valuePattern, line)
        if match:
            argName = match.group(1)
            argValue = match.group(2).strip()
            if argName in initArgs:
                # Resolve piSeed references to actual values
                resolvedValue = resolvePiSeedValue(argValue, seedContent)
                initArgs[argName]['value'] = resolvedValue

    return initArgs


def shouldPreserveElegantPattern(seedContent: str, className: str, codeType: str, codeLines: List[str], options: dict = {}) -> bool:
    """Determine if we should preserve elegant piSeed patterns instead of syncing - IMPROVED CHANGE DETECTION"""
    printIt('shouldPreserveElegantPattern', showDefNames02)

    # IMPROVED LOGIC: Only preserve patterns if they are truly default/generated and haven't been meaningfully modified
    # The default behavior is now to always detect real changes and sync them

    # TARGETED FIX 1: Only preserve strCode if it's truly a default generated pattern
    if codeType == 'strCode':
        # Check if this is a default generated __str__ method that hasn't been customized
        if codeLines and len(codeLines) > 0:
            codeStr = '\n'.join(codeLines)
            # Only preserve if it's the exact default pattern
            if (f'rtnStr = "{className} = ' in codeStr and
                'return rtnStr' in codeStr and
                'rtnStr +=' in codeStr and
                    len([line for line in codeLines if line.strip()]) <= 5):  # Very simple default pattern
                if options and options.get('stats', False):
                    printIt(
                        f"PRESERVE: {codeType} for {className} - exact default pattern", lable.DEBUG)
                return True
        # For any other strCode, sync it (user has customized it)
        return False

    # TARGETED FIX 2: Only preserve fromImports if they are clearly auto-generated
    if codeType == 'fromImports':
        # Only preserve if ALL imports look auto-generated
        if codeLines:
            autoGenCount = 0
            totalCount = len(codeLines)
            for line in codeLines:
                lineStr = str(line).strip()
                # Check for very specific auto-generated patterns
                if ('from .pi' in lineStr or 'from pi.' in lineStr or
                        lineStr.startswith('from .') and 'import Pi' in lineStr):
                    autoGenCount += 1

            # Only preserve if ALL imports are clearly auto-generated
            if autoGenCount == totalCount and totalCount > 0:
                if options and options.get('stats', False):
                    printIt(
                        f"PRESERVE: {codeType} for {className} - all imports auto-generated", lable.DEBUG)
                return True
        # For any other imports, sync them (user has customized them)
        return False

    # TARGETED FIX 3: Only preserve jsonCode if it's truly default
    if codeType == 'jsonCode':
        if codeLines and len(codeLines) > 0:
            codeStr = '\n'.join(codeLines)
            # Only preserve if it's the exact default pattern
            if ('def json(self):' in codeStr and
                'return {' in codeStr and
                    len([line for line in codeLines if line.strip()]) <= 10):  # Simple default pattern
                initArgs = extractInitArgsFromSeed(seedContent, className)
                isDefault = isDefaultJsonCode(codeLines, className, initArgs)
                if isDefault:
                    if options and options.get('stats', False):
                        printIt(
                            f"PRESERVE: {codeType} for {className} - exact default pattern", lable.DEBUG)
                    return True
        # For any other jsonCode, sync it (user has customized it)
        return False

    # TARGETED FIX 4: Be more selective about initAppendCode
    if codeType == 'initAppendCode':
        # Only preserve if it's truly default initialization
        if codeLines:
            initArgs = extractInitArgsFromSeed(seedContent, className)
            isDefault = isDefaultInitAppendCode(codeLines, initArgs)
            if isDefault:
                if options and options.get('stats', False):
                    printIt(
                        f"PRESERVE: {codeType} for {className} - default initialization", lable.DEBUG)
                return True
        # For any other initAppendCode, sync it (user has customized it)
        return False

    # For structural elements, be more permissive to allow real changes
    if codeType in ['imports', 'constants', 'headers']:
        # Only preserve if they are completely empty or clearly auto-generated
        if not codeLines or len(codeLines) == 0:
            return True
        # Otherwise, sync them to capture user changes
        return False

    # For globalCode, always sync to capture user changes
    if codeType == 'globalCode':
        return False

    # Default: allow syncing to capture real changes
    if options and options.get('stats', False):
        printIt(
            f"SYNC: {codeType} for {className} - allowing sync for real changes", lable.DEBUG)

    return False  # Allow syncing by default

def findExistingPiSeedFile(filePath: Path, dest_dir: str) -> tuple[Path | None, str | None]:
    """
    Find existing piSeed file for a class, checking all types.
    Returns (piSeedFile_path, piSeed_type) or (None, None) if not found.
    Priority: piClassGC -> piGenClass -> piDefGC
    """
    printIt('findExistingPiSeedFile', showDefNames02)

    # Check piClassGC first (most common for single classes)
    piSeedFile = findPiClassGCSeedFile(filePath, dest_dir)
    if piSeedFile:
        return piSeedFile, "piClassGC"

    # Check piGenClass second
    piSeedFile = findPiGenClassSeedFile(filePath, dest_dir)
    if piSeedFile:
        return piSeedFile, "piGenClass"

    # Check piDefGC last (for function files)
    piSeedFile = findPiDefGCSeedFile(filePath, dest_dir)
    if piSeedFile:
        return piSeedFile, "piDefGC"

    return None, None

def findPiDefGCSeedFile(py_file: Path, dest_dir: str | None = None) -> Optional[Path]:
    """Find the piSeed file that corresponds to a given function definition name (piDefGC)"""
    printIt('findPiDefGCSeedFile', showDefNames03)
    try:
        defName = py_file.stem
        seedPath = getSeedPath()
        if dest_dir is not None:
            py_file_dir = dest_dir
        else:
            py_file_dir = py_file.parent

        # Look for piSeed files that contain piDefGC for this def name
        seedFiles = list(seedPath.glob(f"*_piDefGC_{defName}.pi"))
        for seedFile in seedFiles:
            try:
                with open(seedFile, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Look for piDefGC line with this def name
                    fileDirectoryPattern = rf"(piValue {defName}\.piBody:piDefGC:fileDirectory\s+(.+))"
                    # Search for the pattern in the line
                    match = re.search(fileDirectoryPattern,
                                      content, re.MULTILINE)
                    if match:
                        # print('content:', content)
                        rawFileDirectory = match.group(2)
                        # rawFileDirectory is already clean (no quotes), so use it directly
                        fileDirectory = rawFileDirectory
                        if fileDirectory == py_file_dir:
                            return seedFile
            except Exception:
                continue
        return None
    except Exception as e:
        if devExept:
            tb_str = ''.join(traceback.format_exception(
                None, e, e.__traceback__))
            printIt(f'{tb_str}\n\n --- def findPiDefGCSeedFile', lable.ERROR)
        printIt(
            f"Error finding piDefGC piSeed file for {defName}: {e}", lable.ERROR)
        return None

def findPiGenClassSeedFile(py_file: Path, dest_dir: str | None = None) -> Optional[Path]:
    """Find the piSeed file that corresponds to a given class name (piGenClass)"""
    printIt('findPiGenClassSeedFile', showDefNames03)
    try:
        className = py_file.stem
        seedPath = getSeedPath()
        if dest_dir is not None:
            py_file_dir = dest_dir

        else:
            py_file_dir = py_file.parent

        # Look for piSeed files that contain piGenClass for this class
        seedFiles = list(seedPath.glob(f"*_piGenClass_{className}.pi"))
        for seedFile in seedFiles:
            try:
                with open(seedFile, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Look for piClassGC line with this def name
                    fileDirectoryPattern = rf"(piValue {className}\.piBody:piGenClass:fileDirectory\s+'([^']+)')"
                    # Search for the pattern in the line
                    match = re.search(fileDirectoryPattern,
                                      content, re.MULTILINE)
                    if match:
                        rawFileDirectory = match.group(2)
                        # rawFileDirectory is already clean (no quotes), so use it directly
                        fileDirectory = rawFileDirectory
                        if fileDirectory == py_file_dir:
                            return seedFile
            except Exception:
                continue
        return None
    except Exception as e:
        if devExept:
            tb_str = ''.join(traceback.format_exception(
                None, e, e.__traceback__))
            printIt(f'{tb_str}\n\n --- def findPiGenClassSeedFile', lable.ERROR)
        printIt(
            f"Error finding piGenClass piSeed file for {className}: {e}", lable.ERROR)
        return None

def findPiClassGCSeedFile(py_file: Path, dest_dir: str | None = None) -> Optional[Path]:
    """Find the piSeed file that corresponds to a given class name (piClassGC)"""
    printIt('findPiClassGCSeedFile', showDefNames03)
    try:
        className = py_file.stem
        seedPath = getSeedPath()
        if dest_dir is not None:
            py_file_dir = dest_dir
        else:
            py_file_dir = py_file.parent

        # Look for piSeed files that contain piClassGC for this class
        seedFiles = list(seedPath.glob(f"*_piClassGC_{className}.pi"))

        for seedFile in seedFiles:
            try:
                with open(seedFile, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Look for piClassGC line with this def name
                    regex_pattern = rf"(piValue {className}\.piBody:piClassGC:fileDirectory\s+'([^']+)')"
                    # Search for the pattern in the line
                    match = re.search(regex_pattern, content, re.MULTILINE)
                    if match:
                        fileDirectory = match.group(2)
                        if (fileDirectory) == str(py_file_dir):
                            return seedFile
            except Exception:
                continue
        return None
    except Exception as e:
        if devExept:
            tb_str = ''.join(traceback.format_exception(None, e, e.__traceback__))
            printIt(f'{tb_str}\n\n --- def findPiClassGCSeedFile', lable.ERROR)
        printIt(
            f"Error finding piClassGC piSeed file for {className}: {e}", lable.ERROR)
        return None

def isPythonFileDefType(filePath: Path) -> bool:
    """
    Analyze a Python file to determine if it's more likely a function definition file (piDefGC)
    or a class file (piClassGC) based on content analysis.
    """
    printIt('isPythonFileDefType', showDefNames02)
    try:
        with open(filePath, 'r', encoding='utf-8') as f:
            content = f.read()

        # Count class definitions vs function definitions
        class_count = len(re.findall(r'^class\s+\w+', content, re.MULTILINE))
        function_count = len(re.findall(r'^def\s+\w+', content, re.MULTILINE))

        # If there are classes, it's likely a class file
        if class_count > 0:
            return False

        # If there are only functions and no classes, it's likely a def file
        if function_count > 0 and class_count == 0:
            return True

        # Default to class file if unclear
        return False

    except Exception:
        # Default to class file if we can't analyze
        return False

def getDestDirForFile(py_file: Path, options) -> str:
    """
    Replaces a source path based on a destination path, matching up to
    the last common parent directory.

    If the source path ends with a file name (e.g., 'logIt.py'), the new
    path will end at the parent directory of that file.

    Args:
        source_path: The original path string.
        destination_path: The replacement path string.

    Returns:
        The new path string.
    """
    printIt('getDestDirForFile', showDefNames02)
    # Normalize paths to handle different OS separators and remove redundant parts
    source_path_str = str(py_file)
    destination_path_str = options['dest_dir']

    # Handle the case where the destination path is empty
    if not destination_path_str:
        source_path = Path(source_path_str)
        # Use Path.suffix to check for a file extension
        if source_path.is_file():
            return str(source_path.parent)
        return str(source_path)

    # Convert string paths to pathlib Path objects
    source_path = Path(source_path_str)
    destination_path = Path(destination_path_str)

    # Use Path.parts to get the path components as a tuple
    source_parts = source_path.parts
    dest_parts = destination_path.parts

    # Find the last common directory component
    common_dir_idx_in_source = -1
    common_dir_idx_in_dest = -1

    # Iterate from the end of source_parts to find the last common component
    for i in range(len(source_parts) - 1, -1, -1):
        part = source_parts[i]
        try:
            dest_idx = dest_parts.index(part)
            common_dir_idx_in_source = i
            common_dir_idx_in_dest = dest_idx
            break
        except ValueError:
            continue

    # Determine the parts of the source path to append
    path_to_append = []
    if common_dir_idx_in_source != -1:
        # Use Path.suffix to check for a file extension
        is_file = source_path.suffix != ''

        # Append all parts of the source path from the common directory onwards
        # If it's a file, we stop at its parent directory
        if is_file:
            path_to_append = list(
                source_parts[common_dir_idx_in_source + 1:-1])
        else:
            path_to_append = list(source_parts[common_dir_idx_in_source + 1:])

        # Combine the destination path up to the common directory with the appended parts
        final_parts = list(
            dest_parts[:common_dir_idx_in_dest + 1]) + path_to_append
    else:
        # If no common directory is found, the logic is to replace the first part
        # of the source path with the entire destination path.
        is_file = source_path.suffix != ''
        if is_file:
            path_to_append = list(source_parts[1:-1])
        else:
            path_to_append = list(source_parts[1:])
        final_parts = list(dest_parts) + path_to_append

    # Use Path.joinpath to join the final parts
    return str(Path().joinpath(*final_parts))

def determineOptimalPiSeedType(pythonFile: Path) -> str:
    """
    Determine the optimal piSeed type for a Python file:
    - piDefGC: Function definitions, no classes
    - piGenClass: Multiple classes or complex single classes
    - piClassGC: Simple single class (for backward compatibility)
    """
    printIt('determineOptimalPiSeedType', showDefNames02)
    try:
        with open(pythonFile, 'r', encoding='utf-8') as f:
            content = f.read()

        # Try to parse the Python file - handle syntax errors gracefully
        try:
            tree = ast.parse(content)
        except SyntaxError as e:
            printIt(
                f"WARN: Syntax error in {pythonFile.name}: {e}. Skipping file type analysis.", lable.WARN)
            return "piClassGC"  # Default fallback for malformed files
        except Exception as e:
            if devExept:
                tb_str = ''.join(traceback.format_exception(None, e, e.__traceback__))
                printIt(f'{tb_str}\n\n --- def determineOptimalPiSeedType', lable.ERROR)
            printIt(f"WARN: Parse error in {pythonFile.name}: {e}. Skipping file type analysis.", lable.WARN)
            return "piClassGC"  # Default fallback

        classes = []
        functions = []

        # Count classes and functions
        for node in tree.body:
            if isinstance(node, ast.ClassDef):
                classes.append(node)
            elif isinstance(node, ast.FunctionDef):
                functions.append(node)
        # Decision logic
        if len(classes) == 0:
            return "piDefGC"  # No classes, use function definitions
        elif len(classes) > 1:
            return "piGenClass"  # Multiple classes, use piGenClass
        elif len(classes) == 1:
            # Single class - check complexity
            class_node = classes[0]

            # Check for inheritance
            if class_node.bases:
                inherited_classes = []
                for base_node in class_node.bases:
                    # We check for ast.Name nodes, which represent simple class names
                    if isinstance(base_node, ast.Name):
                        inherited_classes.append(base_node.id)
                if 'PiPi' in inherited_classes:
                    return "piClassGC"
            return "piGenClass"  # Has inheritance, use piGenClass

    except Exception as e:
        if devExept:
            tb_str = ''.join(traceback.format_exception(None, e, e.__traceback__))
            printIt(f'{tb_str}\n\n --- def determineOptimalPiSeedType', lable.ERROR)
        printIt(
            f"WARN: Error analyzing file type for {pythonFile.name}: {e}. Using default piClassGC.", lable.WARN)
    return "piClassGC"  # Safe fallback

def getDocString(inLine: int, method_name: str, memethodNameSeeds: dict, method_code: list) -> Tuple[str, int]:

    mlLines = ''
    origStr = memethodNameSeeds[method_name]
    line: str
    inLine2 = inLine
    while inLine2 < len(method_code):
        line = method_code[inLine2]
        if mlLines:
            if line.strip().endswith(('"""', "'''")):
                newStr = line.strip().replace('"""','')
                newStr = newStr.replace("'''",'')
                mlLines += newStr.strip()
                if mlLines[-2:] == '\\n':
                    mlLines = mlLines[:-2]
                methodNameSeed = origStr.replace(
                    f"'Method {method_name} extracted from existing code'", f"'{mlLines}'",)
                return methodNameSeed, inLine2 - 1
            else:
                mlLines += line.strip() + '\\n'
        else:
            if line.strip().startswith(('"""',"'''")):
                if line.strip().endswith(('"""',"'''")):
                    newStr = line.strip().replace('"""','')
                    newStr = newStr.replace("'''",'')
                    methodNameSeed = origStr.replace(f"'Method {method_name} extracted from existing code'",f"'{newStr}'")
                    return methodNameSeed, inLine2 - 1
                else:
                    newStr = line.strip().replace('"""', '')
                    newStr = newStr.replace("'''", '')
                    mlLines = newStr + '\\n'
        inLine2 += 1
    inLine2 -= 1
    return origStr, inLine2

def updatePiSeedFileDirectory(piSeedFile: Path, className: str, piSeedType: str, dest_dir: str) -> bool:
    """
    Update the fileDirectory in a piSeed file.

    Args:
        piSeedFile: Path to the piSeed file
        className: Name of the class or definition
        piSeedType: Type of piSeed file (piClassGC, piDefGC, piGenClass)
        dest_dir: New destination directory

    Returns:
        bool: True if the file was updated, False otherwise
    """
    printIt('updatePiSeedFileDirectory', showDefNames03)
    try:
        # Read the piSeed file
        with open(piSeedFile, 'r', encoding='utf-8') as f:
            content = f.read()

        # Create the pattern to match the fileDirectory line
        pattern = f"piValue {className}.piBody:{piSeedType}:fileDirectory '.*'"
        replacement = f"piValue {className}.piBody:{piSeedType}:fileDirectory '{dest_dir}'"

        # Replace the fileDirectory line
        import re
        new_content = re.sub(pattern, replacement, content)

        # Write the updated content back to the file
        with open(piSeedFile, 'w', encoding='utf-8') as f:
            f.write(new_content)

        return True
    except Exception as e:
        printIt(
            f"Error updating fileDirectory in {piSeedFile}: {e}", lable.ERROR)
        return False

def extract_ImportFrom(node: ast.ImportFrom) -> Tuple[str, list]:
    printIt('extract_ImportFrom', showDefNames03)
    module_name = ''
    imports = []
    # Reconstruct the relative part based on 'level'
    if node.level > 0:
        module_name += "." * node.level
    if node.module:
        module_name += node.module
        for alias in node.names:
            import_name = alias.name
            if alias.asname:
                import_name = f"{alias.name} as {alias.asname}"
            imports.append(import_name)
    else:
        # This case handles 'from . import some_name' or 'from .. import some_name'
        # where the 'module' attribute is None. The full path is just the dots.
        if node.level == 0:  # This means 'from __future__ import ...' for example
            module_name = '__future__'
            for alias in node.names:
                import_name = alias.name
                if alias.asname:
                    import_name = f"{alias.name} as {alias.asname}"
                imports.append(import_name)
        else:
            # The module_name is already just the dots
            # 'from .. import some_name'
            pass

    return module_name, imports

def printPythonFileInfo(pythonFile: Path, info: Dict[str, Any]):
    dumpDir = Path('dump/').joinpath(pythonFile.parent)
    dumpDir.mkdir(parents=True, exist_ok=True)
    dumpFile = dumpDir.joinpath(pythonFile.stem + '.json')
    with open(dumpFile, 'w') as wf:
        dump(info, wf, indent=2)

def extractCompleteClassCode(pythonContent: str, classNode: ast.ClassDef) -> List[str]:
    """Extract the complete code for a class including all methods and nested classes"""
    printIt('extractCompleteClassCode', showDefNames03)
    try:
        lines = pythonContent.split('\n')
        startLine = classNode.lineno - 1  # ast uses 1-based line numbers

        # Find the end of the class
        endLine = len(lines)

        # Get the indentation of the class definition
        classLine = lines[startLine]
        classIndent = len(classLine) - len(classLine.lstrip())

        # Find where this class ends by looking for the next line with same or less indentation
        for i in range(startLine + 1, len(lines)):
            line = lines[i]
            if line.strip():  # Non-empty line
                lineIndent = len(line) - len(line.lstrip())
                # If we find a line with same or less indentation than class def, class is done
                if lineIndent <= classIndent:
                    endLine = i
                    break

        # Extract class lines, preserving relative indentation
        classLines = []
        for i in range(startLine, endLine):
            line = lines[i]
            if i == startLine:
                # First line (class definition) - remove base indentation
                classLines.append(line[classIndent:] if len(
                    line) > classIndent else line.strip())
            else:
                # Subsequent lines - preserve relative indentation
                if line.strip():  # Non-empty line
                    if len(line) > classIndent:
                        # Remove the base class indentation, keep relative indentation
                        classLines.append(line[classIndent:])
                    else:
                        classLines.append(line.strip())
                else:
                    # Empty line
                    classLines.append("")

        # Remove trailing blank lines to prevent accumulation
        return removeTrailingBlankLines(classLines)

    except Exception as e:
        printIt(f"Error extracting complete class code: {e}", lable.ERROR)
        return []
        return []

def getNextPiSeedNumber() -> str:
    """Get the next available piSeed number as a zero-padded string"""
    printIt('getNextPiSeedNumber', showDefNames03)
    try:
        seedPath = getSeedPath()

        # Find all piSeed files and extract numbers
        seedFiles = list(seedPath.glob("piSeed*.pi"))
        numbers = []

        for seedFile in seedFiles:
            match = re.match(r'piSeed(\d+)_.*\.pi', seedFile.name)
            if match:
                numbers.append(int(match.group(1)))

        if not numbers:
            return "001"

        # Return next available number as zero-padded string
        nextNum = max(numbers) + 1
        return f"{nextNum:03d}"

    except Exception as e:
        printIt(f"Error getting next piSeed number: {e}", lable.ERROR)
        return "001"

def mapMethodToCodeElement(methodName: str) -> Optional[str]:
    """Map Python method names to piSeed code element names"""
    printIt('mapMethodToCodeElement', showDefNames03)
    method_mapping = {
        '__str__': 'strCode',
        'json': 'jsonCode',
        '__init__': None,  # Special handling needed for init code
    }

    # Check for exact matches first
    if methodName in method_mapping:
        return method_mapping[methodName]

    # Skip special Python methods (double underscore methods except __str__ and __init__)
    if methodName.startswith('__') and methodName.endswith('__'):
        return None

    # All other methods (including private methods with single underscore) go into classDefCode
    return 'classDefCode'


def removeTrailingBlankLines(lines: List[str]) -> List[str]:
    """Remove trailing blank lines from a list of code lines"""
    printIt('removeTrailingBlankLines', showDefNames03)
    if not lines:
        return lines

    # Make a copy to avoid modifying the original
    cleaned_lines = lines[:]

    # Remove trailing empty lines
    while cleaned_lines and not cleaned_lines[-1].strip():
        cleaned_lines.pop()

    return cleaned_lines


def extractMethodCode(method_name: str, pythonContent: str, methodNode: ast.FunctionDef) -> Tuple[bool, List[str]]:
    """Extract the code lines for a method from the Python content"""
    printIt('extractMethodCode', showDefNames03)
    try:
        lines = pythonContent.split('\n')
        isPropertry = False
        if '@property' in lines[methodNode.lineno-2]:
            isPropertry = True
            startLine = methodNode.lineno - 2  # ast uses 1-based line numbers
        elif f'@{method_name}' in lines[methodNode.lineno-2]:
            isPropertry = True
            startLine = methodNode.lineno - 2  # ast uses 1-based line numbers
        else:
            startLine = methodNode.lineno - 1  # ast uses 1-based line numbers

        # Find the end of the method
        endLine = len(lines)

        # Get the indentation of the method definition
        defLine = lines[startLine]
        methodIndent = len(defLine) - len(defLine.lstrip())

        # Find where this method ends
        skipFirstSameIndent = isPropertry
        for i in range(startLine + 1, len(lines)):
            line = lines[i]
            if line.strip():  # Non-empty line
                lineIndent = len(line) - len(line.lstrip())
                # If we find a line with same or less indentation than method def, method is done
                if lineIndent <= methodIndent:
                    if skipFirstSameIndent:
                        skipFirstSameIndent = False
                    else:
                        endLine = i
                        break

        # Extract method lines, preserving relative indentation
        methodLines = []
        for i in range(startLine, endLine):
            line = lines[i]
            if i == startLine:
                # First line (method definition) - remove class indentation
                methodLines.append(line[methodIndent:] if len(line) > methodIndent else line.strip())
            else:
                # Subsequent lines - preserve relative indentation
                if line.strip():  # Non-empty line
                    if len(line) > methodIndent:
                        # Remove the base method indentation, keep relative indentation
                        methodLines.append(line[methodIndent:])
                    else:
                        methodLines.append(line.strip())
                else:
                    # Empty line
                    methodLines.append("")

        # Remove trailing blank lines to prevent accumulation
        return isPropertry, removeTrailingBlankLines(methodLines)

    except Exception as e:
        printIt(f"Error extracting method code: {e}", lable.ERROR)
        return isPropertry, []

def updateSeedCodeElement(seedContent: str, className: str, codeElementName: str, methodCode: List[str]) -> Tuple[str, bool]:
    """
    Update a code element in the piSeed file content with proper ordering.
    Returns (updated_content, was_changed)
    """
    printIt('updateSeedCodeElement', showDefNames03)
    try:
        lines = seedContent.split('\n')
        newLines = []
        changed = False

        # Pattern to match the specific code element
        elementPattern = rf'^piValueA\s+{re.escape(className)}\.piBody:piClassGC:{re.escape(codeElementName)}\s+'

        # Extract existing code element content for comparison
        existingCode = []
        i = 0
        foundElement = False

        while i < len(lines):
            line = lines[i]

            # Check if this line matches our code element pattern
            if re.match(elementPattern, line):
                if not foundElement:
                    foundElement = True
                    # Extract existing code lines
                    while i < len(lines) and re.match(elementPattern, lines[i]):
                        # Extract the quoted content
                        match = re.match(
                            rf'^piValueA\s+{re.escape(className)}\.piBody:piClassGC:{re.escape(codeElementName)}\s+"(.*)"$', lines[i])
                        if match:
                            # Unescape quotes and normalize for comparison
                            existingLine = match.group(1).replace('\\"', '"')
                            existingCode.append(existingLine)
                        i += 1

                    # Normalize both existing and new code for comparison
                    # Remove trailing empty lines for comparison but preserve internal structure
                    def normalizeCodeForComparison(codeLines):
                        # Remove trailing empty lines
                        while codeLines and not codeLines[-1].strip():
                            codeLines.pop()
                        return [line.strip() for line in codeLines if line.strip() or any(codeLines[i+1:])]

                    normalizedExisting = normalizeCodeForComparison(
                        existingCode.copy())
                    normalizedNew = normalizeCodeForComparison(
                        methodCode.copy())

                    # Compare normalized code
                    if normalizedExisting != normalizedNew:
                        # Content is different, replace with new code
                        for codeLine in methodCode:
                            # Escape quotes in code lines properly
                            escapedCode = escapeQuotesForPiSeed(codeLine)
                            newLines.append(
                                f'piValueA {className}.piBody:piClassGC:{codeElementName} "{escapedCode}"')
                        changed = True
                    else:
                        # Content is the same, keep existing code (preserve original formatting)
                        for existingLine in existingCode:
                            # Keep the original escaped format from the piSeed
                            originalEscaped = existingLine.replace('"', '\\"')
                            newLines.append(
                                f'piValueA {className}.piBody:piClassGC:{codeElementName} "{originalEscaped}"')
                        # No change needed
                        for existingLine in existingCode:
                            escapedCode = existingLine.replace('"', '\\"')
                            newLines.append(
                                f'piValueA {className}.piBody:piClassGC:{codeElementName} "{escapedCode}"')
                    continue
                else:
                    # Skip remaining lines (already processed above)
                    i += 1
                    continue
            else:
                newLines.append(line)
                i += 1

        # If we didn't find the element, add it in the correct position
        if not foundElement:
            insertIndex = findCorrectInsertionPosition(
                newLines, className, codeElementName)
            # Insert new code element at the correct position
            for idx, codeLine in enumerate(methodCode):
                escapedCode = escapeQuotesForPiSeed(codeLine)
                newLines.insert(
                    insertIndex + idx, f'piValueA {className}.piBody:piClassGC:{codeElementName} "{escapedCode}"')
            changed = True

        return '\n'.join(newLines), changed

    except Exception as e:
        printIt(f"Error updating seed code element: {e}", lable.ERROR)
        return seedContent, False


def findCorrectInsertionPosition(lines: List[str], className: str, codeElementName: str) -> int:
    """
    Find the correct position to insert a code element based on piSeed ordering rules.

    Correct order:
    1. headers
    2. imports/fromImports
    3. piClassName
    4. inheritance (if present)
    5. initArguments
    6. preSuperInitCode (if present)
    7. postSuperInitCode (if present)
    8. initAppendCode (if present)
    9. genProps (if present)
    10. strCode ←
    11. jsonCode
    12. classDefCode
    """
    printIt(f'findCorrectInsertionPosition: {className}', showDefNames)
    #print(codeElementName)
    # Define the correct ordering of piSeed elements
    elementOrder = [
        'headers',
        'fromImports',
        'imports',
        'piClassName',
        'inheritance',
        'initArguments',
        'preSuperInitCode',
        'postSuperInitCode',
        'initAppendCode',
        'genProps',
        'strCode',
        'jsonCode',
        'classDefCode'
    ]

    try:
        targetIndex = elementOrder.index(codeElementName)
    except ValueError:
        # Unknown element, insert at end
        return len(lines)

    # Find the last occurrence of elements that should come before our target
    insertIndex = 0
    classPattern = rf'^piValueA\s+{re.escape(className)}\.piBody:piClassGC:(\w+)'
    structPattern = rf'^piStruct[AC]\d+\s+{re.escape(className)}\.piBody:piClassGC:(\w+)'
    valuePattern = rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:(\w+)'

    for i, line in enumerate(lines):
        # Check for piValueA elements
        match = re.match(classPattern, line)
        if match:
            elementName = match.group(1)
            try:
                elementIndex = elementOrder.index(elementName)
                if elementIndex < targetIndex:
                    insertIndex = i + 1
            except ValueError:
                pass

        # Check for piStruct elements (like initArguments)
        match = re.match(structPattern, line)
        if match:
            elementName = match.group(1)
            try:
                elementIndex = elementOrder.index(elementName)
                if elementIndex < targetIndex:
                    insertIndex = i + 1
            except ValueError:
                pass

        # Check for piValue elements (like piClassName)
        match = re.match(valuePattern, line)
        if match:
            elementName = match.group(1)
            try:
                elementIndex = elementOrder.index(elementName)
                if elementIndex < targetIndex:
                    insertIndex = i + 1
            except ValueError:
                pass

    return insertIndex


def generateExpectedInitMethod(seedContent: str, className: str) -> str:
    """
    Generate the expected __init__ method from piSeed using piGenCode logic.
    This recreates what the __init__ method should look like based on the original piSeed.
    """
    printIt('generateExpectedInitMethod', showDefNames03)
    try:
        # Extract initArguments from seed content in the correct format
        initArgs = extractInitArgsFromSeedDetailed(seedContent, className)
        if not initArgs:
            return ""

        # Create a minimal piGenCode instance to generate the expected method
        genCode = PiGenCode()
        genCode.initArguments = initArgs
        genCode.inheritance = []  # Assume no inheritance for now - can be enhanced
        genCode.preSuperInitCode = []
        genCode.postSuperInitCode = []
        genCode.initAppendCode = []
        genCode.genProps = False

        # Generate the expected __init__ method
        expectedMethod = genCode.__genInitCodeLines(
            1)  # iniLevel=1 for class method

        return expectedMethod.strip()

    except Exception as e:
        printIt(f"Error generating expected init method: {e}", lable.ERROR)
        return ""


def generateExpectedDefaultStrCode(className: str, initArgs: Dict[str, Dict[str, str]], inheritance: List[str] = [], seedContent: str = "") -> List[str]:
    """
    Generate the expected default __str__ method that piGenCode would create
    when no strCode is present in the piSeed file.
    """
    printIt('generateExpectedDefaultStrCode', showDefNames03)
    try:
        if inheritance is None:
            inheritance = []

        lines = []
        # No class-level indentation - piGenCode will add it during generation
        lines.append("def __str__(self):")

        # Use the actual piClassName from the piSeed, not the lowercase version
        actualClassName = getActualClassName(
            seedContent, className) if seedContent else className

        # Handle inheritance - if class has inheritance, generate super() call pattern
        if inheritance and len(inheritance) > 0:
            # For inherited classes, piGenCode generates a simple super() call
            lines.append("    rtnStr = super().__str__()")
            lines.append("    return rtnStr")
            lines.append("")
            return lines

        # Handle regular parameters for non-inherited classes
        lines.append(f'    rtnStr = "{actualClassName} = ' + '{\\n"')

        param_names = list(initArgs.keys())
        for i, param_name in enumerate(param_names):
            param_info = initArgs[param_name]
            param_type = param_info.get("type", "str")

            if param_type.startswith("Pi"):
                # Complex Pi type handling - skip for now
                pass
            elif param_type.startswith("pi"):
                # Complex pi type handling - skip for now
                pass
            else:
                # Simple parameter - generate exact format
                if i == len(param_names) - 1:
                    # Last parameter - no comma
                    lines.append(
                        f'    rtnStr += f\'    "{param_name}":"{{self.{param_name}}}"\\n\'')
                else:
                    # Not last parameter - include comma
                    lines.append(
                        f'    rtnStr += f\'    "{param_name}":"{{self.{param_name}}}",\\n\'')

        lines.append('    rtnStr += "}"')
        lines.append('    return rtnStr')
        lines.append('')

        return lines

    except Exception as e:
        printIt(f"Error generating expected default strCode: {e}", lable.ERROR)
        return []


def extractJsonCodeWithComparison(pythonContent: str, jsonNode: ast.FunctionDef, className: str, seedContent: str) -> List[str]:
    """
    Enhanced version that compares actual json() method with expected default method from piGenCode.
    This prevents capturing auto-generated jsonCode as custom modifications.
    """
    printIt('extractJsonCodeWithComparison', showDefNames03)
    try:
        # Extract actual json() method
        actualJsonCode = extractJsonCode_original(
            pythonContent, jsonNode, className)

        if not actualJsonCode:
            return []

        # Generate expected default json() method
        initArgs = extractInitArgsFromSeedDetailed(seedContent, className)
        inheritance = extractInheritanceFromSeed(seedContent, className)
        expectedDefaultJsonCode = generateExpectedDefaultJsonCode(
            className, initArgs, inheritance, seedContent)

        if not expectedDefaultJsonCode:
            # Can't generate expected default, return actual (safe fallback)
            printIt(
                f"DEBUG: Could not generate expected default jsonCode for {className}", lable.DEBUG)
            return actualJsonCode

        # Compare actual vs expected default
        if areSimilarCodeBlocks(actualJsonCode, expectedDefaultJsonCode):
            # Actual matches default - don't sync (let piGenCode generate it)
            return []
        else:
            # Actual is different from default - sync the custom code
            return actualJsonCode

    except Exception as e:
        printIt(f"Error in enhanced jsonCode extraction: {e}", lable.ERROR)
        printIt(f"Traceback: {traceback.format_exc()}", lable.ERROR)
        return extractJsonCode_original(pythonContent, jsonNode, className)


def generateExpectedDefaultJsonCode(className: str, initArgs: Dict[str, Dict[str, str]], inheritance: List[str] = [], seedContent: str = "") -> List[str]:
    """
    Generate the expected default json() method that piGenCode would create
    when no jsonCode is present in the piSeed file.
    """
    printIt('generateExpectedDefaultJsonCode', showDefNames03)
    try:
        if inheritance is None:
            inheritance = []

        lines = []
        # No class-level indentation - piGenCode will add it during generation
        lines.append("def json(self) -> dict:")
        lines.append("    rtnDict = {")

        # Handle inheritance - piGenCode has complex logic for inherited classes
        if inheritance and len(inheritance) > 0:
            # For inherited classes, piGenCode generates complex inheritance handling
            # This is very complex to replicate exactly, so for now we'll be conservative
            # and not try to match inherited class json methods exactly
            # This means inherited classes with default json methods might be synced
            # but that's safer than missing custom methods
            lines.append("    }")
            lines.append("    return rtnDict")
            lines.append("")
            lines.append("")
            return lines

        # Handle regular parameters for non-inherited classes
        param_names = list(initArgs.keys())
        for i, param_name in enumerate(param_names):
            param_info = initArgs[param_name]
            param_type = param_info.get("type", "str")

            if param_type.startswith("Pi"):
                # Complex Pi type handling - skip for now
                pass
            elif param_type.startswith("pi"):
                # Complex pi type handling - skip for now
                pass
            elif param_name != 'fileName':  # piGenCode skips fileName parameter
                # Simple parameter - generate exact format
                if i == len(param_names) - 1:
                    # Last parameter - no comma
                    lines.append(f'        "{param_name}": self.{param_name}')
                else:
                    # Not last parameter - include comma
                    lines.append(f'        "{param_name}": self.{param_name},')

        lines.append('    }')
        lines.append('    return rtnDict')
        lines.append('')  # Add blank line to match actual extraction
        # Add second blank line to match actual extraction pattern
        lines.append('')

        return lines

    except Exception as e:
        printIt(
            f"Error generating expected default jsonCode: {e}", lable.ERROR)
        return []


def extractJsonCode_original(pythonContent: str, jsonNode: ast.FunctionDef, className: str) -> List[str]:
    """Original jsonCode extraction logic - strips class-level indentation"""
    printIt('extractJsonCode_original', showDefNames03)
    lines = pythonContent.split('\n')
    startLine = jsonNode.lineno - 1

    # Find method end
    endLine = len(lines)
    methodIndent = len(lines[startLine]) - len(lines[startLine].lstrip())

    for i in range(startLine + 1, len(lines)):
        if lines[i].strip() and len(lines[i]) - len(lines[i].lstrip()) <= methodIndent:
            endLine = i
            break

    # Extract method lines and strip class-level indentation (4 spaces)
    methodLines = []
    for i in range(startLine, endLine):
        line = lines[i]
        # Strip class-level indentation (4 spaces) if present
        if line.startswith('    '):
            line = line[4:]  # Remove 4 spaces
        methodLines.append(line)

    # Remove trailing blank lines to prevent accumulation
    return removeTrailingBlankLines(methodLines)


def extractStrCodeWithComparison(pythonContent: str, strNode: ast.FunctionDef, className: str, seedContent: str) -> List[str]:
    """
    Enhanced version that compares actual __str__ method with expected default method from piGenCode.
    This prevents capturing auto-generated strCode as custom modifications.
    """
    printIt('extractStrCodeWithComparison', showDefNames03)
    try:
        # Extract actual __str__ method
        actualStrCode = extractStrCode_original(
            pythonContent, strNode, className)

        if not actualStrCode:
            return []

        # Generate expected default __str__ method
        initArgs = extractInitArgsFromSeedDetailed(seedContent, className)
        inheritance = extractInheritanceFromSeed(seedContent, className)
        expectedDefaultStrCode = generateExpectedDefaultStrCode(
            className, initArgs, inheritance, seedContent)

        if not expectedDefaultStrCode:
            # Can't generate expected default, return actual (safe fallback)
            return actualStrCode

        # Compare actual vs expected default
        if areSimilarCodeBlocks(actualStrCode, expectedDefaultStrCode):
            # Actual matches default - don't sync (let piGenCode generate it)
            return []
        else:
            # Actual is different from default - sync the custom code
            return actualStrCode

    except Exception as e:
        printIt(f"Error in enhanced strCode extraction: {e}", lable.ERROR)
        printIt(f"Traceback: {traceback.format_exc()}", lable.ERROR)
        return extractStrCode_original(pythonContent, strNode, className)


def getActualClassName(seedContent: str, className: str) -> str:
    """Get the actual piClassName from the piSeed content"""
    printIt('getActualClassName', showDefNames03)
    lines = seedContent.split('\n')

    for line in lines:
        match = re.match(
            rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:piClassName\s+(.+)$', line)
        if match:
            return match.group(1).strip()

    # Fallback to the provided className
    return className


def extractInheritanceFromSeed(seedContent: str, className: str) -> List[str]:
    """Extract inheritance information from piSeed content"""
    printIt('extractInheritanceFromSeed', showDefNames03)
    inheritance = []
    lines = seedContent.split('\n')

    for line in lines:
        if f'{className}.piBody:piClassGC:inheritance' in line:
            match = re.match(
                rf'^piValueA\s+{re.escape(className)}\.piBody:piClassGC:inheritance\s+"(.+)"$', line)
            if match:
                inheritance.append(match.group(1))

    return inheritance


def extractStrCode_original(pythonContent: str, strNode: ast.FunctionDef, className: str) -> List[str]:
    """Original strCode extraction logic - strips class-level indentation"""
    printIt('extractStrCode_original', showDefNames03)
    lines = pythonContent.split('\n')
    startLine = strNode.lineno - 1

    # Find method end
    endLine = len(lines)
    methodIndent = len(lines[startLine]) - len(lines[startLine].lstrip())

    for i in range(startLine + 1, len(lines)):
        if lines[i].strip() and len(lines[i]) - len(lines[i].lstrip()) <= methodIndent:
            endLine = i
            break

    # Extract method lines and strip class-level indentation (4 spaces)
    methodLines = []
    for i in range(startLine, endLine):
        line = lines[i]
        # Strip class-level indentation (4 spaces) if present
        if line.startswith('    '):
            line = line[4:]  # Remove 4 spaces
        methodLines.append(line)

    # Remove trailing blank lines to prevent accumulation
    return removeTrailingBlankLines(methodLines)
    """Extract initArguments from seed content in the format expected by piGenCode"""
    lines = seedContent.split('\n')
    initArgs = {}

    # Find argument definitions
    argPattern = rf'^piStructC01\s+argument\s+(\w+)\.\s*$'
    typePattern = rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:initArguments:(\w+):type\s+(.+)$'
    valuePattern = rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:initArguments:(\w+):value\s+(.+)$'

    # First pass: find all arguments
    for line in lines:
        match = re.match(argPattern, line)
        if match:
            argName = match.group(1)
            initArgs[argName] = {'type': 'str', 'value': ''}

    # Second pass: find types and values
    for line in lines:
        # Check for type definitions
        match = re.match(typePattern, line)
        if match:
            argName = match.group(1)
            argType = match.group(2).strip()
            if argName in initArgs:
                initArgs[argName]['type'] = argType

        # Check for value definitions
        match = re.match(valuePattern, line)
        if match:
            argName = match.group(1)
            argValue = match.group(2).strip()
            if argName in initArgs:
                # Resolve piSeed references to actual values
                resolvedValue = resolvePiSeedValue(argValue, seedContent)
                initArgs[argName]['value'] = resolvedValue

    return initArgs


def resolvePiSeedValue(value: str, seedContent: str) -> str:
    """Resolve piSeed references like 'pi.piBase:piType' to their actual values"""
    printIt('resolvePiSeedValue', showDefNames03)
    if not value or not value.startswith('pi.'):
        return value

    try:
        # For references like 'pi.piBase:piType', we need to look up the actual value
        # This is a simplified resolution - in a full implementation, we'd load the actual pi structure

        # Common mappings based on the piSeed structure
        valueMap = {
            'pi.piBase:piType': 'pi',
            'pi.piBase:piTitle': 'pi',
            'pi.piBase:piSD': 'Smallest particle of Pertinent Information, uesed to define base pis.'
        }

        if value in valueMap:
            return valueMap[value]

        # If not found in map, try to extract from seedContent
        # Look for piValuesSetD definitions
        lines = seedContent.split('\n')
        for line in lines:
            if f'piValue {value}' in line:
                parts = line.split(' ', 2)
                if len(parts) >= 3:
                    return parts[2].strip().strip('"\'')

        # If still not found, return the original value
        return value

    except Exception as e:
        printIt(f"Error resolving piSeed value {value}: {e}", lable.DEBUG)
        return value


def extractInitCodeWithComparison(pythonContent: str, initNode: ast.FunctionDef, className: str, seedContent: str) -> Dict[str, List[str]]:
    """
    Enhanced version that compares actual __init__ method with expected method from piSeed.
    This prevents capturing auto-generated code as custom modifications by comparing components.
    """
    printIt('extractInitCodeWithComparison', showDefNames03)
    try:
        # Generate expected __init__ method components from original piSeed
        expectedComponents = generateExpectedInitComponents(
            seedContent, className)

        if not expectedComponents:
            return extractInitCode_original(pythonContent, initNode, className)

        # Parse actual __init__ method into components
        actualComponents = parseActualInitMethod(
            pythonContent, initNode, className)

        if not actualComponents:
            return extractInitCode_original(pythonContent, initNode, className)

        # Compare components and extract only genuine differences
        #print('expectedComponents', dumps(expectedComponents,indent=2))
        #print('actualComponents', dumps(actualComponents,indent=2))
        result = compareInitComponents(
            expectedComponents, actualComponents, seedContent, className)

        return result

    except Exception as e:
        printIt(f"Error in enhanced init code extraction: {e}", lable.ERROR)
        return extractInitCode_original(pythonContent, initNode, className)


def generateExpectedInitComponents(seedContent: str, className: str) -> Dict[str, list[str]]:
    """
    Generate the expected __init__ method components from piSeed.
    Returns dict with: signature, preSuperInitCode, assignments, postSuperInitCode, initAppendCode
    """
    printIt('generateExpectedInitComponents', showDefNames03)
    try:
        # Extract existing piSeed components
        lines = seedContent.split('\n')

        # Extract initArguments
        initArgs = extractInitArgsFromSeedDetailed(seedContent, className)

        # Extract existing code components from piSeed
        preSuperInitCode: list[str] = []
        postSuperInitCode: list[str] = []
        initAppendCode: list[str] = []
        inheritance: list[str] = []

        # Parse existing piSeed for these components
        for line in lines:
            if f'{className}.piBody:piClassGC:preSuperInitCode' in line:
                match = re.match(
                    rf'^piValueA\s+{re.escape(className)}\.piBody:piClassGC:preSuperInitCode\s+"(.+)"$', line)
                if match:
                    preSuperInitCode.append(match.group(1))
            elif f'{className}.piBody:piClassGC:postSuperInitCode' in line:
                match = re.match(
                    rf'^piValueA\s+{re.escape(className)}\.piBody:piClassGC:postSuperInitCode\s+"(.+)"$', line)
                if match:
                    postSuperInitCode.append(match.group(1))
            elif f'{className}.piBody:piClassGC:initAppendCode' in line:
                match = re.match(
                    rf'^piValueA\s+{re.escape(className)}\.piBody:piClassGC:initAppendCode\s+"(.+)"$', line)
                if match:
                    initAppendCode.append(match.group(1))
            elif f'{className}.piBody:piClassGC:inheritance' in line:
                match = re.match(
                    rf'^piValueA\s+{re.escape(className)}\.piBody:piClassGC:inheritance\s+"(.+)"$', line)
                if match:
                    inheritance.append(match.group(1))

        # Generate expected method signature
        signature_parts = ['def __init__(self']
        for argName, argInfo in initArgs.items():
            argType = argInfo.get('type', 'str')
            argValue = argInfo.get('value', '')
            if argValue:
                signature_parts.append(
                    f'                 {argName}: {argType} = "{argValue}"')
            else:
                signature_parts.append(
                    f'                 {argName}: {argType}')
        signature_parts.append('):')

        # Generate expected standard assignments
        standard_assignments = []
        for argName in initArgs.keys():
            standard_assignments.append(f'        self.{argName} = {argName}')

        return {
            'signature': signature_parts,
            'preSuperInitCode': preSuperInitCode,
            'standard_assignments': standard_assignments,
            'postSuperInitCode': postSuperInitCode,
            'initAppendCode': initAppendCode,
            'inheritance': inheritance
        }

    except Exception as e:
        printIt(f"Error generating expected init components: {e}", lable.ERROR)
        return {}


def parseActualInitMethod(pythonContent: str, initNode: ast.FunctionDef, className: str) -> Dict[str, list[str]]:
    """
    Parse the actual __init__ method into components.
    Returns dict with: signature, preSuperInitCode, assignments, postSuperInitCode, initAppendCode
    """
    printIt('parseActualInitMethod', showDefNames03)
    try:
        lines = pythonContent.split('\n')
        startLine = initNode.lineno - 1

        # Find method end
        endLine = len(lines)
        methodIndent = len(lines[startLine]) - len(lines[startLine].lstrip())

        for i in range(startLine + 1, len(lines)):
            if lines[i].strip() and len(lines[i]) - len(lines[i].lstrip()) <= methodIndent:
                endLine = i
                break

        # Extract method lines
        methodLines: list[str] = lines[startLine:endLine]

        # Parse signature (method definition lines)
        signature: list[str] = []
        bodyStartIndex = 0
        for i, line in enumerate(methodLines):
            signature.append(line)
            if line.strip().endswith(':'):
                bodyStartIndex = i + 1
                break

        # Parse body lines (remove indentation)
        bodyLines: list[str] = []
        for i in range(bodyStartIndex, len(methodLines)):
            line = methodLines[i]
            if line.strip():
                # Remove method body indentation (typically 8 spaces)
                if line.startswith('        '):
                    bodyLines.append(line[8:])
                else:
                    bodyLines.append(line.strip())
            else:
                bodyLines.append('')

        # Remove trailing empty lines
        while bodyLines and not bodyLines[-1].strip():
            bodyLines.pop()

        # Get expected standard assignments from the method signature
        expectedAssignments = extractExpectedAssignments(signature)

        # Analyze body components
        preSuperInitCode: list[str] = []
        standard_assignments: list[str] = []
        postSuperInitCode: list[str] = []
        initAppendCode: list[str] = []

        # Find super() call if it exists
        superCallIndex = -1
        for i, line in enumerate(bodyLines):
            if 'super(' in line and '__init__' in line:
                openParentheses = line.count('(') - line.count(')')
                superCallIndex = i
                break

        if superCallIndex >= 0:
            # Has inheritance - split around super() call
            preSuperInitCode = [
                line for line in bodyLines[:superCallIndex] if line.strip()]

            # Process lines after super() call
            postSuperLines = bodyLines[superCallIndex + 1:]
            standard_assignments, remaining_lines = extractStandardAssignments(
                postSuperLines, expectedAssignments)
            if remaining_lines:
                while openParentheses:
                    remaining_line = remaining_lines.pop(0).strip()
                    openParentheses = openParentheses + remaining_line.count('(') - remaining_line.count(')')
                    if not remaining_lines:
                        break
            postSuperInitCode = [line for line in remaining_lines if line.strip()]
        else:
            # No inheritance - process all body lines
            standard_assignments, remaining_lines = extractStandardAssignments(
                bodyLines, expectedAssignments)

            # Split remaining lines into pre-assignment and post-assignment
            if standard_assignments:
                # Find where standard assignments start and end
                firstAssignmentIndex = -1
                lastAssignmentIndex = -1

                for i, line in enumerate(bodyLines):
                    line_stripped = line.strip()
                    if line_stripped in [assign.strip() for assign in standard_assignments]:
                        if firstAssignmentIndex == -1:
                            firstAssignmentIndex = i
                        lastAssignmentIndex = i

                if firstAssignmentIndex >= 0:
                    # Pre-assignment code
                    preSuperInitCode = [
                        line for line in bodyLines[:firstAssignmentIndex] if line.strip()]
                    # Post-assignment code
                    initAppendCode = [
                        line for line in bodyLines[lastAssignmentIndex + 1:] if line.strip()]
                else:
                    # No standard assignments found, everything is custom
                    initAppendCode = [
                        line for line in bodyLines if line.strip()]
            else:
                # No standard assignments, everything is custom
                initAppendCode: list[str] = [
                    line for line in bodyLines if line.strip()]
        items = {
            'signature': signature,
            'preSuperInitCode': preSuperInitCode,
            'standard_assignments': standard_assignments,
            'postSuperInitCode': postSuperInitCode,
            'initAppendCode': initAppendCode
        }
        return items

    except Exception as e:
        printIt(f"Error parsing actual init method: {e}", lable.ERROR)
        printIt(f"Traceback: {traceback.format_exc()}", lable.ERROR)
        return {}


def extractExpectedAssignments(signature: List[str]) -> List[str]:
    """Extract the expected standard assignments from method signature"""
    printIt('extractExpectedAssignments', showDefNames03)
    assignments = []

    # Parse signature to find parameter names
    signature_text = ' '.join(signature)

    # Find parameter definitions
    import re
    param_pattern = r'(\w+):\s*\w+(?:\s*=\s*[^,)]+)?'
    matches = re.findall(param_pattern, signature_text)

    for param_name in matches:
        if param_name != 'self':
            assignments.append(f'self.{param_name} = {param_name}')

    return assignments


def extractStandardAssignments(lines: List[str], expectedAssignments: List[str]) -> tuple[list[str], list[str]]:
    """
    Extract standard assignments from lines and return (assignments, remaining_lines)
    """
    printIt('extractStandardAssignments', showDefNames03)
    found_assignments: list[str] = []
    remaining_lines: list[str] = []
    expected_set = set(assign.strip() for assign in expectedAssignments)

    for line in lines:
        line_stripped = line.strip()
        if line_stripped in expected_set:
            found_assignments.append(line)
        else:
            remaining_lines.append(line)

    return found_assignments, remaining_lines


def compareInitComponents(expected: Dict[str, list[str]], actual: Dict[str, list[str]], seedContent: str, className: str) -> Dict[str, List[str]]:
    """
    Compare expected vs actual __init__ components and return only genuine differences.
    """
    printIt('compareInitComponents', showDefNames03)
    result = {
        'preSuperInitCode': [],
        'postSuperInitCode': [],
        'initAppendCode': []
    }

    try:
        # Check if this class has inheritance by looking for super() calls in expected components
        hasInheritance = len(expected.get('inheritance', [])) > 0

        # Get existing code from piSeed to avoid duplication
        existingPreSuperInitCode = expected.get('preSuperInitCode', [])
        existingPostSuperInitCode = expected.get('postSuperInitCode', [])
        existingInitAppendCode = expected.get('initAppendCode', [])

        # Get the custom code components from actual Python file
        actualPreAssignment = actual.get('preSuperInitCode', [])
        actualPostAssignment = actual.get('initAppendCode', [])

        # Helper function to check if code already exists in piSeed
        def isCodeAlreadyInSeed(newCode: List[str], existingCode: List[str]) -> bool:
            if not newCode or not existingCode:
                return False
            # Simple check - if all lines in newCode exist in existingCode, consider it duplicate
            newCodeSet = set(line.strip() for line in newCode if line.strip())
            existingCodeSet = set(line.strip()
                                  for line in existingCode if line.strip())
            return newCodeSet.issubset(existingCodeSet)

        # Helper function to check if code already exists in ANY existing code section
        def isCodeAlreadyInAnySeed(newCode: List[str]) -> bool:
            if not newCode:
                return False
            return (isCodeAlreadyInSeed(newCode, existingPreSuperInitCode) or
                    isCodeAlreadyInSeed(newCode, existingPostSuperInitCode) or
                    isCodeAlreadyInSeed(newCode, existingInitAppendCode))

        # Only sync if there's genuine custom code (not just standard assignments)
        if actualPreAssignment or actualPostAssignment:
            if hasInheritance:
                # For classes WITH inheritance, use preSuperInitCode and postSuperInitCode
                # But check for duplication with existing code in ANY section
                if actualPreAssignment and not isCodeAlreadyInAnySeed(actualPreAssignment):
                    result['preSuperInitCode'] = actualPreAssignment
                if actualPostAssignment and not isCodeAlreadyInAnySeed(actualPostAssignment):
                    result['postSuperInitCode'] = actualPostAssignment

                # CRITICAL: Never set initAppendCode for classes with inheritance
                # This prevents duplication between postSuperInitCode and initAppendCode
                result['initAppendCode'] = []
            else:
                # For classes WITHOUT inheritance, combine all custom code into initAppendCode
                # But EXCLUDE standard assignments since piGenCode will generate those automatically
                combined_code = []

                # Add pre-assignment custom code
                if actualPreAssignment:
                    combined_code.extend(actualPreAssignment)

                # DO NOT add standard assignments - piGenCode generates these automatically
                # when initAppendCode is used, it REPLACES the entire method body

                # Add post-assignment custom code
                if actualPostAssignment:
                    combined_code.extend(actualPostAssignment)

                # Set initAppendCode with only the custom code, but check for duplication
                if combined_code and not isCodeAlreadyInAnySeed(combined_code):
                    result['initAppendCode'] = combined_code

                # CRITICAL: Ensure we don't set conflicting fields for non-inheritance classes
                result['preSuperInitCode'] = []
                result['postSuperInitCode'] = []

        return result

    except Exception as e:
        printIt(f"Error comparing init components: {e}", lable.ERROR)
        printIt(f"Traceback: {traceback.format_exc()}", lable.ERROR)
        return result


def areSimilarCodeBlocks(block1: List[str], block2: List[str]) -> bool:
    """Check if two code blocks are similar enough to be considered the same"""
    printIt('areSimilarCodeBlocks', showDefNames03)
    if len(block1) != len(block2):
        return False

    for line1, line2 in zip(block1, block2):
        # Normalize whitespace and compare
        norm1 = ' '.join(line1.split())
        norm2 = ' '.join(line2.split())
        if norm1 != norm2:
            return False

    return True


def extractInitCode_original(pythonContent: str, initNode: ast.FunctionDef, className: str) -> Dict[str, List[str]]:
    """
    Original extractInitCode function - kept as fallback.
    """
    printIt('extractInitCode_original', showDefNames03)
    try:
        lines = pythonContent.split('\n')
        startLine = initNode.lineno - 1

        # Find method end
        endLine = len(lines)
        methodIndent = len(lines[startLine]) - len(lines[startLine].lstrip())

        for i in range(startLine + 1, len(lines)):
            line = lines[i]
            if line.strip():
                lineIndent = len(line) - len(line.lstrip())
                if lineIndent <= methodIndent:
                    endLine = i
                    break

        # Extract method body
        methodLines = []
        for i in range(startLine + 1, endLine):  # Skip method definition line
            line = lines[i]
            if line.strip():
                if len(line) > methodIndent + 4:  # Account for method body indentation
                    methodLines.append(line[methodIndent + 4:])
                else:
                    methodLines.append(line.strip())
            else:
                methodLines.append("")

        # Find super() call
        superCallIndex = -1
        for i, line in enumerate(methodLines):
            if 'super(' in line and '__init__' in line:
                superCallIndex = i
                break

        result = {
            'preSuperInitCode': [],
            'postSuperInitCode': [],
            'initAppendCode': []
        }

        if superCallIndex >= 0:
            # Class has inheritance
            result['preSuperInitCode'] = [
                line for line in methodLines[:superCallIndex] if line.strip()]

            # Find where standard assignments start (after super call)
            assignmentStart = superCallIndex + 1
            while assignmentStart < len(methodLines) and not methodLines[assignmentStart].strip().startswith('self.'):
                assignmentStart += 1

            # Find where standard assignments end
            assignmentEnd = assignmentStart
            while assignmentEnd < len(methodLines) and methodLines[assignmentEnd].strip().startswith('self.') and '=' in methodLines[assignmentEnd]:
                assignmentEnd += 1

            result['postSuperInitCode'] = [
                line for line in methodLines[assignmentEnd:] if line.strip()]
        else:
            # Class has no inheritance - all custom code goes to initAppendCode
            # Find where standard assignments end
            assignmentEnd = 0
            while assignmentEnd < len(methodLines) and methodLines[assignmentEnd].strip().startswith('self.') and '=' in methodLines[assignmentEnd]:
                assignmentEnd += 1

            result['initAppendCode'] = [
                line for line in methodLines[assignmentEnd:] if line.strip()]

        return result

    except Exception as e:
        printIt(f"Error extracting init code: {e}", lable.ERROR)
        return {'preSuperInitCode': [], 'postSuperInitCode': [], 'initAppendCode': []}


def extractInitArguments(initNode: ast.FunctionDef) -> Dict[str, Dict[str, str]]:
    """
    Extract constructor arguments from __init__ method.
    Returns dict with argument names as keys and type/default info as values.
    """
    printIt('extractInitArguments', showDefNames03)
    try:
        arguments = {}

        # Process function arguments
        for arg in initNode.args.args:
            if arg.arg != 'self':  # Skip 'self' parameter
                arg_info = {
                    'type': 'str',  # Default type
                    'value': '""'   # Default value
                }

                # Try to infer type from type annotation
                if arg.annotation:
                    if isinstance(arg.annotation, ast.Name):
                        arg_info['type'] = arg.annotation.id
                    elif isinstance(arg.annotation, ast.Constant):
                        arg_info['type'] = str(arg.annotation.value)

                arguments[arg.arg] = arg_info

        # Process default values
        if initNode.args.defaults:
            # Map defaults to arguments (defaults apply to last N arguments)
            num_defaults = len(initNode.args.defaults)
            num_args = len(initNode.args.args) - 1  # Exclude 'self'

            for i, default in enumerate(initNode.args.defaults):
                arg_index = num_args - num_defaults + i
                if arg_index >= 0:
                    # +1 to skip 'self'
                    arg_name = initNode.args.args[arg_index + 1].arg

                    if arg_name in arguments:
                        # Extract default value
                        if isinstance(default, ast.Constant):
                            if isinstance(default.value, str):
                                arguments[arg_name]['value'] = f'"{default.value}"'
                            else:
                                arguments[arg_name]['value'] = str(
                                    default.value)
                        elif isinstance(default, ast.Name):
                            arguments[arg_name]['value'] = default.id
                        elif isinstance(default, ast.List):
                            # Handle list defaults
                            list_items = []
                            for item in default.elts:
                                if isinstance(item, ast.Constant):
                                    if isinstance(item.value, str):
                                        list_items.append(f'"{item.value}"')
                                    else:
                                        list_items.append(str(item.value))
                            arguments[arg_name]['value'] = f'[{", ".join(list_items)}]'
                            arguments[arg_name]['type'] = 'list'
                        else:
                            # For complex expressions, convert to string
                            arguments[arg_name]['value'] = ast.unparse(default)

        return arguments

    except Exception as e:
        printIt(f"Error extracting init arguments: {e}", lable.ERROR)
        return {}


def escapeQuotesForPiSeed(text: str) -> str:
    """Properly escape quotes for piSeed format, avoiding double-escaping"""
    printIt('escapeQuotesForPiSeed', showDefNames03)
    if not text:
        return text

    # First, unescape any existing escaped quotes to normalize
    normalized = text.replace('\\"', '"')

    # Then escape quotes for piSeed format
    escaped = normalized.replace('"', '\\"')

    return escaped


def escapeValueForPiSeed(value: str) -> str:
    """Properly escape values for piSeed format"""
    printIt('escapeValueForPiSeed', showDefNames03)
    if not value:
        return '""'

    # If it's already a quoted string, return as-is
    if (value.startswith('"') and value.endswith('"')) or (value.startswith("'") and value.endswith("'")):
        return value

    # If it's a list or other complex type, return as-is
    if value.startswith('[') or value.startswith('{') or value in ['True', 'False', 'None']:
        return value

    # If it's a number, return as-is
    try:
        float(value)
        return value
    except ValueError:
        pass

    # For string values, ensure they're properly quoted
    # Escape any existing quotes within the string
    escaped_value = value.replace('"', '\\"')
    return f'"{escaped_value}"'


def updateSeedInitArguments(seedContent: str, className: str, initArgs: Dict[str, Dict[str, str]]) -> Tuple[str, bool]:
    """
    Update initArguments in the piSeed file content.
    Returns (updated_content, was_changed)
    """
    printIt('updateSeedInitArguments', showDefNames03)
    try:
        lines = seedContent.split('\n')
        newLines = []
        changed = False

        # Patterns to match initArguments entries
        structPattern = rf'^piStructA00\s+{re.escape(className)}\.piBody:piClassGC:initArguments\s*$'
        argStructPattern = rf'^piStructC01\s+argument\s+(\w+)\.\s*$'
        argTypePattern = rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:initArguments:(\w+):type\s+'
        argValuePattern = rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:initArguments:(\w+):value\s+'

        # Extract existing arguments for comparison
        existingArgs = {}
        i = 0
        foundInitArgs = False

        while i < len(lines):
            line = lines[i]

            # Check if we found the initArguments structure declaration
            if re.match(structPattern, line):
                foundInitArgs = True
                newLines.append(line)
                i += 1

                # Extract existing argument definitions
                while i < len(lines):
                    line = lines[i]

                    # Extract argument structure declarations
                    argStructMatch = re.match(argStructPattern, line)
                    if argStructMatch:
                        argName = argStructMatch.group(1)
                        if argName not in existingArgs:
                            existingArgs[argName] = {
                                'type': 'str', 'value': '""'}
                        i += 1
                        continue

                    # Extract argument type definitions
                    argTypeMatch = re.match(argTypePattern, line)
                    if argTypeMatch:
                        argName = argTypeMatch.group(1)
                        # Extract the type part after the pattern
                        typeAfterPattern = re.match(argTypePattern, line)
                        if typeAfterPattern:
                            typePart = line[typeAfterPattern.end():].strip()
                            if argName not in existingArgs:
                                existingArgs[argName] = {
                                    'type': 'str', 'value': '""'}
                            existingArgs[argName]['type'] = typePart
                            i += 1
                            continue
                        else:
                            printIt(
                                f'No type part after pattern for line: {line.strip()}', lable.WARN)
                            i += 1  # Always advance to prevent infinite loop
                            continue
                    # Extract argument value definitions
                    argValueMatch = re.match(argValuePattern, line)
                    if argValueMatch:
                        argName = argValueMatch.group(1)
                        # Extract the value part after the pattern - use argValuePattern not argTypePattern!
                        valueAfterPattern = re.match(argValuePattern, line)
                        if valueAfterPattern:
                            valuePart = line[valueAfterPattern.end():].strip()
                            if argName not in existingArgs:
                                existingArgs[argName] = {
                                    'type': 'str', 'value': '""'}
                            existingArgs[argName]['value'] = valuePart
                            i += 1
                        else:
                            printIt(
                                f'No value part after pattern for line: {line.strip()}', lable.WARN)
                            i += 1  # Always advance to prevent infinite loop
                        continue

                    # If we reach here, we're done with initArguments section
                    break

                # Compare existing arguments with new arguments
                # Normalize both for comparison to avoid unnecessary changes
                def normalizeArgValue(value):
                    """Normalize argument values for comparison"""
                    if not value:
                        return '""'

                    # Handle None values consistently - all None representations should be treated as equivalent
                    valueStr = str(value).strip()
                    if valueStr in ["'None'", '"None"', 'None']:
                        return 'None'  # Canonical form for comparison

                    # Unescape quotes for comparison
                    normalized = valueStr.replace('\\"', '"')

                    # If it's a list with escaped quotes, normalize it
                    if normalized.startswith('[') and '\\"' in valueStr:
                        # This handles cases like [\"stduser\"] vs ["stduser"]
                        normalized = valueStr.replace('\\"', '"')

                    return normalized

                # Normalize existing arguments for comparison
                normalizedExisting = {}
                for argName, argInfo in existingArgs.items():
                    normalizedExisting[argName] = {
                        'type': argInfo['type'],
                        'value': normalizeArgValue(argInfo['value'])
                    }

                # Normalize new arguments for comparison
                normalizedNew = {}
                for argName, argInfo in initArgs.items():
                    normalizedNew[argName] = {
                        'type': argInfo['type'],
                        'value': normalizeArgValue(argInfo['value'])
                    }

                # STRICT IDEMPOTENCY: Only change if normalized values are actually different
                if normalizedExisting == normalizedNew:
                    # Values are equivalent after normalization, keep existing format for idempotency
                    for argName, argInfo in existingArgs.items():
                        newLines.append(f'piStructC01 argument {argName}.')

                    for argName, argInfo in existingArgs.items():
                        newLines.append(
                            f'piValue {className}.piBody:piClassGC:initArguments:{argName}:type {argInfo["type"]}')
                        newLines.append(
                            f'piValue {className}.piBody:piClassGC:initArguments:{argName}:value {argInfo["value"]}')
                    # No change needed for idempotency
                elif normalizedExisting != normalizedNew:
                    # Arguments are different, add new argument definitions
                    for argName, argInfo in initArgs.items():
                        newLines.append(f'piStructC01 argument {argName}.')

                    for argName, argInfo in initArgs.items():
                        escapedValue = escapeValueForPiSeed(argInfo["value"])
                        newLines.append(
                            f'piValue {className}.piBody:piClassGC:initArguments:{argName}:type {argInfo["type"]}')
                        newLines.append(
                            f'piValue {className}.piBody:piClassGC:initArguments:{argName}:value {escapedValue}')

                    changed = True
                else:
                    # Arguments are the same, keep existing definitions
                    for argName, argInfo in existingArgs.items():
                        newLines.append(f'piStructC01 argument {argName}.')

                    for argName, argInfo in existingArgs.items():
                        newLines.append(
                            f'piValue {className}.piBody:piClassGC:initArguments:{argName}:type {argInfo["type"]}')
                        newLines.append(
                            f'piValue {className}.piBody:piClassGC:initArguments:{argName}:value {argInfo["value"]}')

                continue
            else:
                newLines.append(line)
                i += 1

        # If initArguments structure wasn't found, add it
        if not foundInitArgs and initArgs:
            # Find a good place to insert (after piClassName)
            insertIndex = len(newLines)
            classNamePattern = rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:piClassName\s+'

            for idx in range(len(newLines)):
                if re.match(classNamePattern, newLines[idx]):
                    insertIndex = idx + 1
                    break

            # Insert initArguments structure
            newLines.insert(
                insertIndex, f'piStructA00 {className}.piBody:piClassGC:initArguments')
            insertIndex += 1

            # Add argument definitions
            for argName, argInfo in initArgs.items():
                newLines.insert(
                    insertIndex, f'piStructC01 argument {argName}.')
                insertIndex += 1

            for argName, argInfo in initArgs.items():
                escapedValue = escapeValueForPiSeed(argInfo["value"])
                newLines.insert(
                    insertIndex, f'piValue {className}.piBody:piClassGC:initArguments:{argName}:type {argInfo["type"]}')
                insertIndex += 1
                newLines.insert(
                    insertIndex, f'piValue {className}.piBody:piClassGC:initArguments:{argName}:value {escapedValue}')
                insertIndex += 1

            changed = True

        return '\n'.join(newLines), changed

    except Exception as e:
        printIt(f"Error updating seed init arguments: {e}", lable.ERROR)
        return seedContent, False


def extractPiClassTypesFromInitArgs(seedContent: str, className: str) -> Set[str]:
    """
    Extract Pi class types from initArguments in the piSeed file.
    These are classes that genCode will automatically import, so syncCode shouldn't add them to fromImports.

    Returns a set of Pi class names (e.g., {'PiUserProfile', 'PiBase', 'PiIndexer'})
    """
    printIt('extractPiClassTypesFromInitArgs', showDefNames03)
    try:
        piClassTypes = set()
        lines = seedContent.split('\n')

        # Pattern to match initArguments type definitions
        typePattern = rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:initArguments:(\w+):type\s+(.+)$'

        for line in lines:
            line = line.strip()
            match = re.match(typePattern, line)
            if match:
                argName = match.group(1)
                argType = match.group(2).strip('"')

                # Check if this is a Pi class type (starts with Pi and is capitalized)
                if argType.startswith('Pi') and argType[2:3].isupper():
                    piClassTypes.add(argType)
                    if argType.startswith('Pi') and len(argType) > 2:
                        # Also add the module name (e.g., PiUserProfile -> piUserProfile)
                        moduleName = argType[2].lower(
                        ) + argType[3:] if len(argType) > 3 else argType[2:].lower()
                        piClassTypes.add(moduleName)

        return piClassTypes

    except Exception as e:
        printIt(
            f"Error extracting Pi class types from initArgs: {e}", lable.ERROR)
        return set()


def extractImportStatements(importNodes: List) -> Tuple[Dict[str, Dict[str, str]], List[str]]:
    """
    Extract import statements from AST nodes.
    Returns (fromImports_dict, regular_imports_list)
    """
    printIt('extractImportStatements', showDefNames03)
    try:
        fromImports = {}
        regularImports = []

        for node in importNodes:
            if isinstance(node, ast.ImportFrom):
                # Handle "from module import item" statements
                module_name, imports = extract_ImportFrom(node)

                # Clean module name for piSeed structure
                clean_module = module_name.replace('.', '_').replace('-', '_')
                escaped_module = module_name  # module_name.replace(".","//.")

                if module_name not in fromImports:
                    fromImports[clean_module] = {
                        'from': escaped_module,
                        'import': ", ".join(imports)
                    }
                else:
                    # Multiple imports from same module
                    existing_import = fromImports[clean_module]['import']
                    for aImport in imports:
                        if aImport not in existing_import:
                            fromImports[clean_module]['import'] = f"{existing_import}, {aImport}"

            elif isinstance(node, ast.Import):
                # Handle "import module" statements
                for alias in node.names:
                    import_name = alias.name
                    if alias.asname:
                        import_name = f"{alias.name} as {alias.asname}"
                    regularImports.append(import_name)

        return fromImports, regularImports

    except Exception as e:
        printIt(f"Error extracting import statements: {e}", lable.ERROR)
        return {}, []


def updateSeedFromImports(seedContent: str, className: str, fromImports: Dict[str, Dict[str, str]]) -> Tuple[str, bool]:
    """
    Update fromImports in the piSeed file content.
    Returns (updated_content, was_changed)
    """
    printIt('updateSeedFromImports', showDefNames03)
    try:
        lines = seedContent.split('\n')
        newLines = []
        changed = False

        # Patterns to match fromImports entries
        structPattern = rf'^piStructA00\s+{re.escape(className)}\.piBody:piClassGC:fromImports\s*$'
        importStructPattern = rf'^piStructC01\s+fromImports\s+(\w+)\.\s*$'
        importFromPattern = rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:fromImports:(\w+):from\s+'
        importImportPattern = rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:fromImports:(\w+):import\s+'

        i = 0
        foundFromImports = False

        while i < len(lines):
            line = lines[i]

            # Check if we found the fromImports structure declaration
            if re.match(structPattern, line):
                foundFromImports = True
                newLines.append(line)
                i += 1

                # Skip existing import definitions
                while i < len(lines):
                    line = lines[i]
                    if (re.match(importStructPattern, line) or
                        re.match(importFromPattern, line) or
                            re.match(importImportPattern, line)):
                        i += 1
                        continue
                    else:
                        break

                # Add new import definitions
                for module_name, import_info in fromImports.items():
                    # Clean module name for piSeed (replace dots, hyphens with underscores)
                    clean_module = module_name.replace(
                        '.', '_').replace('-', '_')
                    newLines.append(f'piStructC01 fromImports {clean_module}.')

                for module_name, import_info in fromImports.items():
                    clean_module = module_name.replace(
                        '.', '_').replace('-', '_')
                    newLines.append(
                        f'piValue {className}.piBody:piClassGC:fromImports:{clean_module}:from "{import_info["from"]}"')
                    newLines.append(
                        f'piValue {className}.piBody:piClassGC:fromImports:{clean_module}:import "{import_info["import"]}"')

                changed = True
                continue
            else:
                newLines.append(line)
                i += 1

        # If fromImports structure wasn't found, add it
        if not foundFromImports and fromImports:
            # Find a good place to insert (after headers)
            insertIndex = len(newLines)
            headersPattern = rf'^piValueA\s+{re.escape(className)}\.piBody:piClassGC:headers\s+'

            # Look for existing headers section
            for idx in range(len(newLines)):
                if re.match(headersPattern, newLines[idx]):
                    # Find end of headers section
                    insertIndex = idx
                    while insertIndex < len(newLines) and re.match(headersPattern, newLines[insertIndex]):
                        insertIndex += 1
                    break

            # Insert fromImports structure
            newLines.insert(
                insertIndex, f'piStructA00 {className}.piBody:piClassGC:fromImports')
            insertIndex += 1

            # Add import definitions
            for module_name, import_info in fromImports.items():
                clean_module = module_name.replace('.', '_').replace('-', '_')
                newLines.insert(
                    insertIndex, f'piStructC01 fromImports {clean_module}.')
                insertIndex += 1

            for module_name, import_info in fromImports.items():
                clean_module = module_name.replace('.', '_').replace('-', '_')
                newLines.insert(
                    insertIndex, f'piValue {className}.piBody:piClassGC:fromImports:{clean_module}:from "{import_info["from"]}"')
                insertIndex += 1
                newLines.insert(
                    insertIndex, f'piValue {className}.piBody:piClassGC:fromImports:{clean_module}:import "{import_info["import"]}"')
                insertIndex += 1

            changed = True

        return '\n'.join(newLines), changed

    except Exception as e:
        printIt(f"Error updating seed fromImports: {e}", lable.ERROR)
        return seedContent, False


def updateSeedGlobals(seedContent: str, className: str, moduleGlobals: Dict[str, str]) -> Tuple[str, bool]:
    """
    Update globals section in the piSeed file content for module-level assignments.
    Returns (updated_content, was_changed)
    """
    printIt('updateSeedGlobals', showDefNames03)
    if not moduleGlobals:
        return seedContent, False

    lines = seedContent.split('\n')
    newLines = []
    changed = False
    i = 0

    # Find the globals section or create it
    globalsPattern = rf'^piStructA00\s+{re.escape(className)}\.piBody:piClassGC:globals\s*$'
    foundGlobals = False

    while i < len(lines):
        line = lines[i]

        # Check if we found the globals structure declaration
        if re.match(globalsPattern, line):
            foundGlobals = True
            newLines.append(line)
            i += 1

            # Extract existing globals
            existingGlobals = {}
            while i < len(lines):
                line = lines[i]

                # Check for global variable definitions
                globalVarPattern = rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:globals:(\w+)\s+(.+)$'
                globalVarMatch = re.match(globalVarPattern, line)

                if globalVarMatch:
                    varName = globalVarMatch.group(1)
                    varValue = globalVarMatch.group(2)
                    existingGlobals[varName] = varValue
                    i += 1
                    continue

                # If we reach here, we're done with globals section
                break

            # Compare and update globals
            for varName, varValue in moduleGlobals.items():
                if varName not in existingGlobals or existingGlobals[varName] != varValue:
                    newLines.append(
                        f'piValue {className}.piBody:piClassGC:globals:{varName} {varValue}')
                    changed = True
                elif varName in existingGlobals:
                    # Keep existing line
                    newLines.append(
                        f'piValue {className}.piBody:piClassGC:globals:{varName} {existingGlobals[varName]}')

            # Continue with the rest of the file
            continue
        else:
            newLines.append(line)
            i += 1

    # If globals section doesn't exist, create it after the class structure
    if not foundGlobals and moduleGlobals:
        # Find where to insert globals section (after piClassName line)
        insertIndex = -1
        for idx, line in enumerate(newLines):
            classNamePattern = rf'^piValue\s+{re.escape(className)}\.piBody:piClassGC:piClassName\s+'
            if re.match(classNamePattern, line):
                insertIndex = idx + 1
                break

        if insertIndex != -1:
            # Insert globals structure and values
            newLines.insert(
                insertIndex, f'piStructA00 {className}.piBody:piClassGC:globals')
            insertIndex += 1
            for varName, varValue in moduleGlobals.items():
                newLines.insert(
                    insertIndex, f'piValue {className}.piBody:piClassGC:globals:{varName} {varValue}')
                insertIndex += 1
            changed = True

    if changed:
        return '\n'.join(newLines), True
    else:
        return seedContent, False


def updateSeedImports(seedContent: str, className: str, regularImports: List[str]) -> Tuple[str, bool]:
    """Update regular imports in piSeed file"""
    printIt('updateSeedImports', showDefNames03)
    try:
        lines = seedContent.split('\n')
        newLines = []
        changed = False

        # Find existing imports
        existing_imports = set()
        for line in lines:
            if f'{className}.piBody:piClassGC:imports' in line and 'fromImports' not in line:
                # Extract import name from line
                parts = line.split()
                if len(parts) >= 2:
                    existing_imports.add(parts[-1])

        # Add new imports that don't exist
        imports_to_add = []
        for imp in regularImports:
            if imp not in existing_imports:
                imports_to_add.append(
                    f"piValueA {className}.piBody:piClassGC:imports {imp}")
                changed = True


        if changed:
            # Insert imports after fromImports or headers
            chk4FromImports = False
            for i, line in enumerate(lines):
                if chk4FromImports:
                    if 'fromImports' in line:
                        newLines.append(line)
                    else:
                        newLines.extend(imports_to_add)
                        newLines.append(line)
                        chk4FromImports = False
                else:
                    newLines.append(line)
                    if f'{className}.piBody:piClassGC:headers' in line:
                        chk4FromImports = True

            return '\n'.join(newLines), True
        else:
            return seedContent, False

    except Exception as e:
        printIt(f"Error updating seed imports: {e}", lable.ERROR)
        return seedContent, False


def rebuildPiSeedInCorrectOrder(seedContent: str, className: str) -> str:
    """
    Rebuild piSeed file content in the correct order according to piStruct_piClassGC.json.
    This ensures all elements appear in the proper sequence.
    """
    printIt(f'rebuildPiSeedInCorrectOrder: {className}', showDefNames)
    try:
        lines = seedContent.split('\n')
        # Parse existing content into sections
        sections = {
            'header': [],
            'fileDirectory': '',
            'fileName': '',
            'headers': [],
            'fromImports': {},
            'imports': [],
            'fromPiClasses': [],
            'rawFromImports': [],
            'globals': {},
            'piClassName': '',
            'inheritance': [],
            'initArguments': {},
            'classComment': [],
            'preSuperInitCode': [],
            'postSuperInitCode': [],
            'initAppendCode': [],
            'genProps': '',
            'strCode': [],
            'jsonCode': [],
            'classDefCode': {},
            'globalCode': []
        }

        # Parse the existing content
        i = 0
        while i < len(lines):
            line = lines[i].strip()

            # Skip empty lines
            if not line:
                i += 1
                continue

            # Header lines (piClassGC, piProlog, piBase)
            if (line.startswith(f'piClassGC {className}') or
                line.startswith(f'piValue {className}.piProlog') or
                    line.startswith(f'piValue {className}.piBase')):
                sections['header'].append(line)

            # fileDirectory
            elif f'{className}.piBody:piClassGC:fileDirectory' in line:
                sections['fileDirectory'] = line

            # fileName
            elif f'{className}.piBody:piClassGC:fileName' in line:
                sections['fileName'] = line

            # headers
            elif f'{className}.piBody:piClassGC:headers' in line:
                sections['headers'].append(line)

            # fromImports
            elif f'{className}.piBody:piClassGC:fromImports' in line:
                while i < len(line):
                    line = lines[i].strip()
                    if line:
                        piType, piTitle, piSD = extractPiSeed(line)
                        if 'piStructA' in piType and piTitle == f'{className}.piBody:piClassGC:fromImports':
                            sections['fromImports']['piStructA'] = line
                        elif 'piStructC' in piType:
                            currDef = piSD
                            if currDef[-1] == '.':  # strip . copy over key
                                currDef = currDef[:-1]
                            #print('currDef01',currDef)
                            sections['fromImports'][currDef] = []
                            sections['fromImports'][currDef].append(line)
                        elif 'fromImports' in piTitle:
                            currDef = piTitle.split(':')[-2]
                            #print('currDef02',currDef)
                            sections['fromImports'][currDef].append(line)
                        else:
                            i -= 1
                            break
                    i += 1

            # imports
            elif f'{className}.piBody:piClassGC:imports' in line and 'fromImports' not in line:
                sections['imports'].append(line)

            # fromPiClasses  piValueA piPi.piBody:piClassGC:fromPiClasses "PiRealmBody"
            elif f'{className}.piBody:piClassGC:fromPiClasses' in line:
                sections['fromPiClasses'].append(line)

            # rawFromImports
            elif f'{className}.piBody:piClassGC:rawFromImports' in line:
                sections['rawFromImports'].append(line)

            # inheritance
            elif f'{className}.piBody:piClassGC:inheritance' in line:
                sections['inheritance'].append(line)

            # globals
            elif f'{className}.piBody:piClassGC:globals' in line:
                while True:
                    line = lines[i].strip()
                    if line:
                        piType, piTitle, piSD = extractPiSeed(line)
                        if 'piStructA' in piType and piTitle == f'{className}.piBody:piClassGC:globals':
                            sections['globals']['lines'] = []
                            sections['globals']['lines'].append(line)
                        elif 'piValue' == piType:
                            sections['globals']['lines'].append(line)
                        else:
                            i -= 1
                            break
                    i += 1
            # piClassName
            elif f'{className}.piBody:piClassGC:piClassName' in line:
                sections['piClassName'] = line
            # classComment
            elif f'{className}.piBody:piClassGC:classComment' in line:
                sections['classComment'] = line
            # preSuperInitCode
            elif f'{className}.piBody:piClassGC:preSuperInitCode' in line:
                sections['preSuperInitCode'] = line
            # postSuperInitCode
            elif f'{className}.piBody:piClassGC:postSuperInitCode' in line:
                sections['postSuperInitCode'] = line
            # initArguments
            elif f'{className}.piBody:piClassGC:initArguments' in line:
                while True:
                    line = lines[i].strip()
                    if line:
                        piType, piTitle, piSD = extractPiSeed(line)
                        if 'piStructA' in piType and piTitle == f'{className}.piBody:piClassGC:initArguments':
                            sections['initArguments']['piStructA'] = line
                        elif 'piStructC' in piType:
                            currDef = piSD
                            if currDef[-1] == '.':  # strip . copy over key
                                currDef = currDef[:-1]
                            #print('currDef01',currDef)
                            sections['initArguments'][currDef] = []
                            sections['initArguments'][currDef].append(line)
                        elif 'initArguments' in piTitle:
                            currDef = piTitle.split(':')[-2]
                            #print('currDef02',currDef)
                            sections['initArguments'][currDef].append(line)
                        else:
                            i -= 1
                            break
                    i += 1

            # initAppendCode
            elif f'{className}.piBody:piClassGC:initAppendCode' in line:
                sections['initAppendCode'].append(line)
            # genProps
            elif f'{className}.piBody:piClassGC:genProps' in line:
                sections['genProps'].append(line)
            # strCode
            elif f'{className}.piBody:piClassGC:strCode' in line:
                sections['strCode'].append(line)
            # jsonCode
            elif f'{className}.piBody:piClassGC:jsonCode' in line:
                sections['jsonCode'].append(line)

            # classDefCode
            elif f'{className}.piBody:piClassGC:classDefCode' in line:
                while True:
                    line = lines[i].strip()
                    if line:
                        piType, piTitle, piSD = extractPiSeed(line)
                        if 'piStructA' in piType and piTitle == f'{className}.piBody:piClassGC:classDefCode':
                            sections['classDefCode']['piStructA'] = line
                        elif 'piStructL' in piType:
                            currDef = piTitle
                            sections['classDefCode'][currDef] = []
                            sections['classDefCode'][currDef].append(line)
                        elif 'piValueA' in piType and 'classDefCode' in piTitle:
                            currDef = piTitle.split(':')[-1]
                            sections['classDefCode'][currDef].append(line)
                        else:
                            i -= 1
                            break
                    i += 1
                    if i >= len(lines):
                        break
                #print(dumps(sections['classDefCode'],indent=2))
                # exit()

            # globalCode
            elif f'{className}.piBody:piClassGC:globalCode' in line:
                while True:
                    line = lines[i].strip()
                    if line:
                        piType, piTitle, piSD = extractPiSeed(line)
                        if 'piValueA' in piType:
                            sections['globalCode'].append(line)
                        else:
                            i -= 1
                            break
                    i += 1
                    if i >= len(lines):
                        break
            i += 1
        #  ------ end with ----

        # Rebuild in correct order
        result = []

        # 1. Header
        result.extend(sections['header'])

        # 2. fileDirectory
        if sections['fileDirectory']:
            result.append(sections['fileDirectory'])

        # 3. fileName
        if sections['fileName']:
            result.append(sections['fileName'])

        # 4. headers
        result.extend(sections['headers'])

        # 5. imports
        result.extend(sections['imports'])

        # 6. fromImports
        fromImports = sections['fromImports']
        if fromImports:
            capturedLines = []
            for currDef, lines in fromImports.items():
                #print('** currDef', currDef)
                if currDef == 'piStructA':
                    # here lines is a string for fist line declaring fromImports append
                    result.extend([lines])
                else:
                    # here lines is a list for all piValueA classDefCode code
                    #print('** currDef', currDef)
                    #print('** lines',lines)
                    assert len(lines) == 3
                    result.extend(lines[:1])
                    capturedLines.extend(lines[1:])
            result.extend(capturedLines)

        # 7. fromPiClasses
        result.extend(sections['fromPiClasses'])

        # 8. rawFromImports
        result.extend(sections['rawFromImports'])

        # 9. globals
        if sections['globals']:
            result.extend(sections['globals']['lines'])

        # 10. piClassName
        if sections['piClassName']:
            result.append(sections['piClassName'])

        # 11. inheritance
        if sections['inheritance']:
            result.append(sections['inheritance'])

        # 12. initArguments
        capturedLines = []
        initArguments = sections['initArguments']
        if initArguments:
            for currDef, lines in initArguments.items():
                if currDef == 'piStructA':
                    # here lines is a string for fist line declaring classDefCode append
                    result.extend([lines])
                else:
                    result.extend(lines[:1])
                    capturedLines.extend(lines[1:])
            result.extend(capturedLines)

        # 13. classComment
        result.extend(sections['classComment'])
        # 14. preSuperInitCode
        result.extend(sections['preSuperInitCode'])
        # 15. postSuperInitCode
        result.extend(sections['postSuperInitCode'])

        # 16. initAppendCode
        result.extend(sections['initAppendCode'])

        # 17. genProps
        result.extend(sections['genProps'])

        # 18. strCode
        result.extend(sections['strCode'])

        # 19. jsonCode
        result.extend(sections['jsonCode'])

        # 20. classDefCode
        capturedLines = []
        classDefCode = sections['classDefCode']
        if classDefCode:
            for currDef, lines in classDefCode.items():
                if currDef == 'piStructA':
                    # here lines is a string for fist line declaring classDefCode append
                    result.extend([lines])
                else:
                    result.extend(lines[:1])
                    capturedLines.extend(lines[1:])
            result.extend(capturedLines)

        # 21. globalCode
        #print("sections['globalCode']", sections['globalCode'])
        result.extend(sections['globalCode'])
        return '\n'.join(result)

    except Exception as e:
        if devExept:
            tb_str = ''.join(traceback.format_exception(None, e, e.__traceback__))
            printIt(f'{tb_str}\n\n --- def rebuildPiSeedInCorrectOrder', lable.ERROR)
        printIt(f"Error rebuilding piSeed order: {e}", lable.ERROR)
        return seedContent


def extractCallCode(pythonContent: str, exprNode: ast.Expr) -> Optional[str]:
    """Extract expression code from AST node (like method calls, assignments)"""
    printIt('extractCallCode', showDefNames03)
    try:
        lines = pythonContent.split('\n')
        start_line = exprNode.lineno - 1

        if start_line >= len(lines):
            return None

        # Use AST end_lineno information if available (Python 3.8+)
        if hasattr(exprNode, 'end_lineno') and exprNode.end_lineno is not None:
            end_line = exprNode.end_lineno - 1

            if start_line == end_line:
                # Single-line expression
                return lines[start_line].strip()
            else:
                # Multi-line expression
                result_lines = []
                for i in range(start_line, end_line + 1):
                    if i < len(lines):
                        result_lines.append(lines[i].rstrip())
                return '\n'.join(result_lines)

        # Fallback for older Python versions
        return lines[start_line].strip()

    except Exception as e:
        if devExept:
            tb_str = ''.join(traceback.format_exception(None, e, e.__traceback__))
            printIt(f'{tb_str}\n\n --- def extractCallCode', lable.ERROR)
        printIt(f"Error extracting call code: {e}", lable.ERROR)
        return None


def extractAssignmentCode(pythonContent: str, assignNode: ast.Assign) -> Optional[str]:
    """Extract assignment code (constants) from AST node, handling multi-line strings and parentheses"""
    printIt('extractAssignmentCode', showDefNames03)
    try:
        lines = pythonContent.split('\n')
        start_line = assignNode.lineno - 1

        if start_line >= len(lines):
            return None

        # Use AST end_lineno information if available (Python 3.8+)
        if hasattr(assignNode, 'end_lineno') and assignNode.end_lineno is not None:
            end_line = assignNode.end_lineno - 1

            if start_line == end_line:
                # Single-line assignment
                return lines[start_line].strip()
            else:
                # Multi-line assignment
                result_lines = []
                for i in range(start_line, end_line + 1):
                    if i < len(lines):
                        result_lines.append(lines[i].rstrip())
                return '\n'.join(result_lines)

        # Fallback for older Python versions or when end_lineno is not available
        first_line = lines[start_line].strip()

        # Check if this is a multi-line string assignment (be more precise about triple quotes)
        has_triple_double = '"""' in first_line
        has_triple_single = "'''" in first_line

        if has_triple_double or has_triple_single:
            # This is a multi-line string, need to find the end
            quote_type = '"""' if has_triple_double else "'''"

            # Count quotes in first line to see if it's complete
            quote_count = first_line.count(quote_type)

            if quote_count >= 2:
                # Complete multi-line string on one line (e.g., var = """text""")
                return first_line
            elif quote_count == 1:
                # Multi-line string spans multiple lines
                result_lines = [first_line]

                # Find the closing quote
                for i in range(start_line + 1, len(lines)):
                    line = lines[i]
                    # Preserve indentation but remove trailing whitespace
                    result_lines.append(line.rstrip())

                    if quote_type in line:
                        # Found closing quote, we're done
                        break

                return '\n'.join(result_lines)

        # For simple cases, just return the first line
        # (This avoids the complex delimiter counting that was causing issues)
        return first_line

    except Exception as e:
        if devExept:
            tb_str = ''.join(traceback.format_exception(None, e, e.__traceback__))
            printIt(f'{tb_str}\n\n --- def extractAssignmentCode', lable.ERROR)
        printIt(f"Error extracting assignment code: {e}", lable.ERROR)
        return None


def extractIfMainCode(pythonContent: str, ifNode: ast.If) -> List[str]:
    """Extract code from if __name__ == '__main__': block"""
    printIt('extractIfMainCode', showDefNames03)
    try:
        lines = pythonContent.split('\n')
        startLine = ifNode.lineno - 1

        # Find the end of the if block
        endLine = len(lines)
        ifIndent = len(lines[startLine]) - len(lines[startLine].lstrip())

        for i in range(startLine + 1, len(lines)):
            line = lines[i]
            if line.strip():  # Non-empty line
                lineIndent = len(line) - len(line.lstrip())
                if lineIndent <= ifIndent:
                    endLine = i
                    break

        # Extract if block content
        ifCode = []
        for i in range(startLine, endLine):
            line = lines[i]
            if i == startLine:
                # First line (if statement)
                ifCode.append(line.strip())
            else:
                # Subsequent lines - preserve relative indentation
                if line.strip():
                    if len(line) > ifIndent:
                        ifCode.append(line[ifIndent:])
                    else:
                        ifCode.append(line.strip())
                else:
                    ifCode.append("")

        # Remove trailing blank lines to prevent accumulation
        return removeTrailingBlankLines(ifCode)

    except Exception as e:
        if devExept:
            tb_str = ''.join(traceback.format_exception(None, e, e.__traceback__))
            printIt(f'{tb_str}\n\n --- def extractIfMainCode', lable.ERROR)
        printIt(f"Error extracting if main code: {e}", lable.ERROR)
        return []


def extractModuleDocstring(pythonContent: str) -> List[str]:
    """Extract module-level docstring"""
    printIt('extractModuleDocstring', showDefNames03)
    try:
        tree = ast.parse(pythonContent)
        if (tree.body and isinstance(tree.body[0], ast.Expr) and
            isinstance(tree.body[0].value, ast.Constant) and
                isinstance(tree.body[0].value.value, str)):

            docstring = tree.body[0].value.value
            return docstring.split('\n')
        return []

    except Exception as e:
        if devExept:
            tb_str = ''.join(traceback.format_exception(None, e, e.__traceback__))
            printIt(f'{tb_str}\n\n --- def extractModuleDocstring', lable.ERROR)
        printIt(f"Error extracting module docstring: {e}", lable.ERROR)
        return []

def enhancedFileDiscovery(fileName: str) -> Optional[Path]:
    """Enhanced file discovery that searches multiple locations"""
    printIt('enhancedFileDiscovery', showDefNames03)
    try:
        filePath = Path(fileName)

        # If it's already a valid path, return it
        if filePath.exists():
            return filePath

        # Try adding .py extension if missing
        if not filePath.suffix:
            filePath = filePath.with_suffix('.py')
            if filePath.exists():
                return filePath

        # Search in configurable piClassGCDir
        piClassesDir = Path(getKeyItem(piGCDirs[2]))
        if piClassesDir.exists():
            # Direct file in piClasses
            candidate = piClassesDir / fileName
            if candidate.exists():
                return candidate

            # With .py extension
            candidate = piClassesDir / \
                f"{fileName}.py" if not fileName.endswith(
                    '.py') else piClassesDir / fileName
            if candidate.exists():
                return candidate

            # Search recursively in subdirectories
            for subdir in piClassesDir.rglob("*"):
                if subdir.is_dir():
                    candidate = subdir / fileName
                    if candidate.exists():
                        return candidate
                    candidate = subdir / \
                        f"{fileName}.py" if not fileName.endswith(
                            '.py') else subdir / fileName
                    if candidate.exists():
                        return candidate

        # Search in configurable piDefGCDir
        piDefsDir = Path(getKeyItem(piGCDirs[3]))
        if piDefsDir.exists():
            # Direct file in piDefs
            candidate = piDefsDir.joinpath(fileName)
            if candidate.exists():
                return candidate

            # With .py extension
            candidate = piDefsDir / \
                f"{fileName}.py" if not fileName.endswith(
                    '.py') else piDefsDir / fileName
            if candidate.exists():
                return candidate

            # Search recursively in subdirectories
            for subdir in piDefsDir.rglob("*"):
                if subdir.is_dir():
                    candidate = subdir / fileName
                    if candidate.exists():
                        return candidate
                    candidate = subdir / \
                        f"{fileName}.py" if not fileName.endswith(
                            '.py') else subdir / fileName
                    if candidate.exists():
                        return candidate

        return None

    except Exception as e:
        if devExept:
            tb_str = ''.join(traceback.format_exception(None, e, e.__traceback__))
            printIt(f'{tb_str}\n\n --- def enhancedFileDiscovery', lable.ERROR)
        printIt(f"Error in enhanced file discovery for {fileName}: {e}", lable.ERROR)
        return None


def findPythonFilesRecursively(directory: Path, file_type: str) -> List[Tuple[Path, str]]:
    """Find Python files recursively and determine their types"""
    printIt('findPythonFilesRecursively', showDefNames03)
    files = []
    try:
        for py_file in directory.rglob("*.py"):
            if py_file.is_file():
                # Determine the actual type of this file
                actual_type = determineOptimalPiSeedType(py_file)
                files.append((py_file, actual_type))

        # Filter by requested type if specified
        if file_type == "class":
            files = [(f, t) for f, t in files if t == "piClassGC"]
        elif file_type == "def":
            files = [(f, t) for f, t in files if t == "piDefGC"]
        elif file_type == "genclass":
            files = [(f, t) for f, t in files if t == "piGenClass"]

        return files

    except Exception as e:
        printIt(f"Error finding Python files in {directory}: {e}", lable.ERROR)
        return []


def validateSyncResults(pythonFile: Path, piSeedFile: Path, changes: List[str]):
    """Validate sync results and show warnings if needed"""
    printIt(f'validateSyncResults: {pythonFile.name}', showDefNames)
    try:
        warnings = []

        # Check if piSeed file exists and is readable
        if not piSeedFile.exists():
            warnings.append(f"piSeed file not found: {piSeedFile}")
        elif not piSeedFile.is_file():
            warnings.append(f"piSeed path is not a file: {piSeedFile}")
        else:
            try:
                with open(piSeedFile, 'r', encoding='utf-8') as f:
                    content = f.read()
                    if not content.strip():
                        warnings.append(f"piSeed file is empty: {piSeedFile}")
            except Exception as e:
                warnings.append(f"Cannot read piSeed file {piSeedFile}: {e}")

        # Check if Python file is readable
        if not pythonFile.exists():
            warnings.append(f"Python file not found: {pythonFile}")
        elif not pythonFile.is_file():
            warnings.append(f"Python path is not a file: {pythonFile}")
        else:
            try:
                with open(pythonFile, 'r', encoding='utf-8') as f:
                    content = f.read()
                    if not content.strip():
                        warnings.append(f"Python file is empty: {pythonFile}")

                    # Try to parse as Python
                    import ast
                    try:
                        ast.parse(content)
                    except SyntaxError as e:
                        warnings.append(
                            f"Python syntax error in {pythonFile}: {e}")

            except Exception as e:
                warnings.append(f"Cannot read Python file {pythonFile}: {e}")

        # Check if changes were expected but none were made
        if not changes:
            # This might be normal, but worth noting
            printIt(
                f"No changes detected for {pythonFile.name} - file may be up to date", lable.DEBUG)

        # Report warnings
        if warnings:
            printIt(f"Validation warnings for {pythonFile.name}:", lable.WARN)
            for warning in warnings:
                printIt(f"  • {warning}", lable.WARN)
        else:
            printIt(f"Validation passed for {pythonFile.name}", lable.DEBUG)

    except Exception as e:
        if devExept:
            tb_str = ''.join(traceback.format_exception(None, e, e.__traceback__))
            printIt(f'{tb_str}\n\n --- def findPythonFilesRecursively', lable.ERROR)
        printIt(f"Error validating sync results: {e}", lable.ERROR)


def printSyncCodeHelp():
    """Print enhanced help for syncCode command"""
    help_text = """
syncCode - Synchronize Python files back to piSeed definitions

USAGE:
    piGenCode syncCode [options] [filename|directory]

OPTIONS:
    --dry-run              Show what would be changed without making changes
    --create-piSeeds       Auto-create piSeed files for specified Python files that don't have piSeeds
    --validate             Validate sync results and show warnings
    --stats                Show detailed statistics and change information
    --filter <type>        Only sync specific file types (class|def|genclass)
    --exclude-pattern <p>  Exclude files matching glob pattern
    --dest-dir <dir>       Specify destination directory for generated files
    --help                 Show this help message

EXAMPLES:
    piGenCode syncCode                              # Sync all files
    piGenCode syncCode MyClass.py                   # Sync specific file
    piGenCode syncCode src/models/                  # Sync directory
    piGenCode syncCode --dest-dir hold/<dirname>    # Set destination directory
    piGenCode syncCode --dry-run                    # Preview changes
    piGenCode syncCode --create-piSeeds             # Create piSeed files for specified files
    piGenCode syncCode --filter genclass            # Only sync piGenClass files
    piGenCode syncCode --exclude-pattern "test_*"   # Skip test files
    piGenCode syncCode --stats --validate           # Detailed sync with validation

FILE TYPES:
    class     - Single-class files (piClassGC)
    def       - Function definition files (piDefGC)
    genclass  - Multi-class files (piGenClass)

WORKFLOW:
    1. Modify generated Python files in piClasses/ or piDefs/
    2. Run syncCode to update corresponding piSeed files
    3. Use genCode to regenerate and verify changes
    4. Commit both Python and piSeed changes to version control

The system automatically detects the optimal piSeed type for each file:
- Files with multiple classes → piGenClass
- Files with inheritance or complex single classes → piGenClass
- Files with only functions → piDefGC
- Simple single classes → piClassGC (backward compatibility)
"""
    printIt(help_text, lable.INFO)
